<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Operating System(OS)</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-default_background {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 237, 214, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 237, 214, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
.select-value-color-translucentGray { background-color: rgba(0, 0, 0, 0.06); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(249, 228, 188, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="fa94b13a-71c3-456f-b121-2a62e7b61d1b" class="page sans"><header><h1 class="page-title">Operating System(OS)</h1><p class="page-description"></p><table class="properties"><tbody><tr class="property-row property-row-person"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesPerson"><path d="M10.9536 7.90088C12.217 7.90088 13.2559 6.79468 13.2559 5.38525C13.2559 4.01514 12.2114 2.92017 10.9536 2.92017C9.70142 2.92017 8.65137 4.02637 8.65698 5.39087C8.6626 6.79468 9.69019 7.90088 10.9536 7.90088ZM4.4231 8.03003C5.52368 8.03003 6.42212 7.05859 6.42212 5.83447C6.42212 4.63843 5.51245 3.68945 4.4231 3.68945C3.33374 3.68945 2.41846 4.64966 2.41846 5.84009C2.42407 7.05859 3.32251 8.03003 4.4231 8.03003ZM1.37964 13.168H5.49561C4.87231 12.292 5.43384 10.6074 6.78711 9.51807C6.18628 9.14746 5.37769 8.87231 4.4231 8.87231C1.95239 8.87231 0.262207 10.6917 0.262207 12.1628C0.262207 12.7974 0.548584 13.168 1.37964 13.168ZM7.50024 13.168H14.407C15.4009 13.168 15.7322 12.8423 15.7322 12.2864C15.7322 10.8489 13.8679 8.88354 10.9536 8.88354C8.04492 8.88354 6.17505 10.8489 6.17505 12.2864C6.17505 12.8423 6.50635 13.168 7.50024 13.168Z"></path></svg></span>Owner</th><td><span class="user"><img src="https://lh3.googleusercontent.com/a-/AOh14GhTOj1PuBid-LtJDhB48wRhBLm3943Cr9c9yhV4YQ=s100" class="icon user-icon"/>Arnab Chatterjee</span></td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesMultipleSelect"><path d="M1.91602 4.83789C2.44238 4.83789 2.87305 4.40723 2.87305 3.87402C2.87305 3.34766 2.44238 2.91699 1.91602 2.91699C1.38281 2.91699 0.952148 3.34766 0.952148 3.87402C0.952148 4.40723 1.38281 4.83789 1.91602 4.83789ZM5.1084 4.52344H14.3984C14.7607 4.52344 15.0479 4.23633 15.0479 3.87402C15.0479 3.51172 14.7607 3.22461 14.3984 3.22461H5.1084C4.74609 3.22461 4.45898 3.51172 4.45898 3.87402C4.45898 4.23633 4.74609 4.52344 5.1084 4.52344ZM1.91602 9.03516C2.44238 9.03516 2.87305 8.60449 2.87305 8.07129C2.87305 7.54492 2.44238 7.11426 1.91602 7.11426C1.38281 7.11426 0.952148 7.54492 0.952148 8.07129C0.952148 8.60449 1.38281 9.03516 1.91602 9.03516ZM5.1084 8.7207H14.3984C14.7607 8.7207 15.0479 8.43359 15.0479 8.07129C15.0479 7.70898 14.7607 7.42188 14.3984 7.42188H5.1084C4.74609 7.42188 4.45898 7.70898 4.45898 8.07129C4.45898 8.43359 4.74609 8.7207 5.1084 8.7207ZM1.91602 13.2324C2.44238 13.2324 2.87305 12.8018 2.87305 12.2686C2.87305 11.7422 2.44238 11.3115 1.91602 11.3115C1.38281 11.3115 0.952148 11.7422 0.952148 12.2686C0.952148 12.8018 1.38281 13.2324 1.91602 13.2324ZM5.1084 12.918H14.3984C14.7607 12.918 15.0479 12.6309 15.0479 12.2686C15.0479 11.9062 14.7607 11.6191 14.3984 11.6191H5.1084C4.74609 11.6191 4.45898 11.9062 4.45898 12.2686C4.45898 12.6309 4.74609 12.918 5.1084 12.918Z"></path></svg></span>Tags</th><td><span class="selected-value select-value-color-brown">Guides and Processes</span></td></tr></tbody></table></header><div class="page-body"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="8c5a7f1f-dda8-41b5-872d-387e85087c5a"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Two core principle<br/>1. Abstraction<br/>2. Management<br/></div></figure><h3 id="7bc4e2cc-5b92-4f11-8c98-44cb995a18c1" class="">Intro and Types</h3><ul id="1c9dee0a-bc85-4c12-aa9e-162daabfd3b0" class="toggle"><li><details open=""><summary>Types of software</summary><ol type="1" id="3df508cf-d72f-46d9-ac73-ea044469ce35" class="numbered-list" start="1"><li>Application software performs specific task for the user.<br/><br/></li></ol><ol type="1" id="94e87514-6b14-4878-a55a-36aea786d1f9" class="numbered-list" start="2"><li>System software operates and controls the computer system and provides a platform to run<br/>application software.<br/></li></ol></details></li></ul><ul id="c8e85f96-b5c5-44af-83ba-7cad79a16459" class="toggle"><li><details open=""><summary>What is OS</summary><p id="6df7aa5d-d106-4459-99fa-f6020c6e50e6" class="">OS is a system software that manages all the resources of a computer<br/>system,both hardware and software, and provides an environment in which the user can<br/>execute his/her programs in a convenient and efficient manner by hiding underlying<br/>complexity of the hardware and acting as a resource manager.<br/></p><ul id="b7e9d96f-4b9e-464c-a160-503431138d3b" class="bulleted-list"><li style="list-style-type:disc">Access to the computer hardware.</li></ul><ul id="876b772a-1d51-4f64-891e-5f5eaedf207b" class="bulleted-list"><li style="list-style-type:disc">interface between the user and the computer hardware</li></ul><ul id="d9023bd2-560a-4665-862c-ebe8a654bb72" class="bulleted-list"><li style="list-style-type:disc">Resource management (Aka, Arbitration) (memory, device, file, security, process etc)</li></ul><ul id="e0069288-6177-43fe-b9ac-6cc89bdb0776" class="bulleted-list"><li style="list-style-type:disc">Hides the underlying complexity of the hardware. (Aka, Abstraction)</li></ul><ul id="745e4ed7-9919-4f81-b069-78b5500b6d5c" class="bulleted-list"><li style="list-style-type:disc">facilitates execution of application programs by providing isolation and protection.</li></ul><hr id="26aa4d6d-6ac9-477f-9684-e68303095520"/><h3 id="89a0e9ba-b80f-4e10-9cf0-63eab63db78a" class="">Functioning</h3><ul id="63e38029-1d9d-466c-82e0-991a11f2e0a0" class="bulleted-list"><li style="list-style-type:disc"><strong>Process Management</strong>: Handling the creation, scheduling, and termination of processes.</li></ul><ul id="aa79c948-4031-4a47-89f1-71bf5777d053" class="bulleted-list"><li style="list-style-type:disc"><strong>Memory Management</strong>: Managing the allocation and deallocation of memory spaces as needed by programs.</li></ul><ul id="e43bfe08-bb24-436f-a855-74c7a66d9055" class="bulleted-list"><li style="list-style-type:disc"><strong>File System Management</strong>: Organizing and managing data storage in files and directories.</li></ul><ul id="63666a97-2978-40e0-aaff-84e610671536" class="bulleted-list"><li style="list-style-type:disc"><strong>Device Management</strong>: Controlling and managing input/output devices like printers, disk drives, etc.</li></ul><ul id="59fca4e5-8bda-4099-a76d-516ae37665ea" class="bulleted-list"><li style="list-style-type:disc"><strong>Security and Access Control</strong>: Protecting data and resources from unauthorized access and ensuring system integrity.</li></ul><ul id="c36997fd-80e4-4475-888d-686fd1959966" class="bulleted-list"><li style="list-style-type:disc"><strong>User Interface</strong>: Providing a user interface, such as command-line or graphical user interface (GUI), to interact with the system.</li></ul></details></li></ul><ul id="6e598e34-a2c0-43ab-bf92-40635dc1e702" class="toggle"><li><details open=""><summary>What if there is no OS</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="c50d3ace-859d-414f-8b42-d73510bde91b"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">In short<br/>1. Resources will be badly exploited by some programs as a result no other program can run<br/><br/>2. No memory protection. If two apps are running , both of them require memory. Now a program can exploit the memory of other program leading to security issues<br/><br/>3. Bulky apps. If we need to include manually memory management in every code, the size of program will definitely increase<br/></div></figure><ol type="1" id="788b4b94-3352-4117-9545-cc982b4ee008" class="numbered-list" start="1"><li><strong>Manual Hardware Management</strong>: Users would have to manage hardware resources manually, which is complex and inefficient.</li></ol><ol type="1" id="01f3e35e-ab3a-4696-9d95-eb71d094dc3a" class="numbered-list" start="2"><li><strong>No Standard Interface</strong>: There would be no standard interface for running applications, making software development and execution highly inconsistent.</li></ol><ol type="1" id="bd9b387d-8477-4181-afbd-cf68ecec15e2" class="numbered-list" start="3"><li><strong>Security Risks</strong>: Without an OS to enforce security measures, the system would be vulnerable to unauthorized access and malicious attacks.</li></ol><ol type="1" id="56118b88-438d-46cc-a30b-db34b510f187" class="numbered-list" start="4"><li><strong>Poor Resource Management</strong>: Efficiently allocating CPU, memory, and storage resources would be challenging, leading to poor system performance.</li></ol><ol type="1" id="227fb63d-f095-4b4b-8d97-676059c9977d" class="numbered-list" start="5"><li><strong>Incompatibility Issues</strong>: Each application would need to include code to manage hardware directly, leading to incompatibility and redundancy.</li></ol><h3 id="b08c5046-b059-456f-a753-a5a1c8b4f101" class=""></h3></details></li></ul><ul id="6272083a-85d6-4cd5-a66e-c1cb123ef279" class="toggle"><li><details open=""><summary>Why OS</summary><ul id="e5b48916-eb3f-4b54-82e5-8722ae0f6858" class="bulleted-list"><li style="list-style-type:disc"><strong>Resource Management</strong>: It efficiently manages hardware and software resources, ensuring optimal performance.</li></ul><ul id="fd93439a-fc67-44e3-a02d-5618e4dc268e" class="bulleted-list"><li style="list-style-type:disc"><strong>User Convenience</strong>: Provides a user-friendly interface for interaction with the system.</li></ul><ul id="dde9b0c0-5a7f-477b-ba70-ceb2cf562a0c" class="bulleted-list"><li style="list-style-type:disc"><strong>Application Support</strong>: Offers a platform for running and managing applications consistently.</li></ul><ul id="f83457cd-cd31-4af2-a95a-ab349e14fd18" class="bulleted-list"><li style="list-style-type:disc"><strong>Security</strong>: Implements security measures to protect data and system integrity.</li></ul><ul id="c57c1d4a-0cd3-4a49-9894-e319b1e6b0da" class="bulleted-list"><li style="list-style-type:disc"><strong>Abstraction</strong>: Abstracts complex hardware details, allowing users and developers to work at a higher level of abstraction.</li></ul><ul id="3f89f1b8-e2ac-44f5-9dbc-3f79360d80ac" class="bulleted-list"><li style="list-style-type:disc"><strong>Multitasking</strong>: Enables the concurrent execution of multiple applications, improving productivity.</li></ul><ul id="c511f92c-660d-4f01-9c57-79d17e0973f2" class="bulleted-list"><li style="list-style-type:disc"><strong>System Stability</strong>: Maintains system stability and prevents crashes by managing resources and processes effectively.</li></ul></details></li></ul><ul id="be2d6b2a-0860-4949-a023-909224acca91" class="toggle"><li><details open=""><summary>Define the term of Abstraction and Management</summary><h3 id="a8d24755-5101-48d3-b827-14d95a5f634e" class="">Abstraction</h3><ol type="1" id="ee1885b3-350f-4562-a3a2-ec96abd2ee4f" class="numbered-list" start="1"><li><strong>Hardware Abstraction</strong>: The OS provides a layer of abstraction over the hardware, making it easier for applications and users to interact with the computer. Instead of dealing with the complexities of hardware, users and developers can use high-level commands and interfaces.<ul id="93b82a0a-0886-4d2b-b7ce-a2ec22cf19a4" class="bulleted-list"><li style="list-style-type:disc"><strong>Examples</strong>: File systems abstract the details of physical storage; APIs abstract the complexities of device interactions.</li></ul></li></ol><ol type="1" id="687119c1-8100-4350-85c8-e4f72ace03c6" class="numbered-list" start="2"><li><strong>Process Abstraction</strong>: The OS abstracts the concept of running programs by managing processes. It provides a simplified model for execution, allowing programs to be run, paused, and stopped without the user needing to manage the CPU directly.</li></ol><h3 id="af16865a-a62a-4351-bc3b-1e16f368df04" class="">Management</h3><ol type="1" id="6ec0369b-1e9c-4553-b8a4-104214169739" class="numbered-list" start="1"><li><strong>Resource Management</strong>: The OS manages the system&#x27;s resources, such as CPU, memory, disk space, and I/O devices. It ensures these resources are allocated efficiently and fairly among all running applications.<ul id="772464d3-ff9e-4b5d-835e-f8ab2fc95346" class="bulleted-list"><li style="list-style-type:disc"><strong>Examples</strong>: The OS schedules processes to ensure fair CPU time distribution; it manages memory allocation to optimize usage and avoid conflicts.</li></ul></li></ol><ol type="1" id="90da2732-09c4-475a-89c7-ef6287bdf180" class="numbered-list" start="2"><li><strong>Process Management</strong>: The OS is responsible for creating, scheduling, and terminating processes. It ensures that each process gets the necessary resources and manages the communication between processes.<ul id="9928c0a5-1b3c-4ecf-9550-d9e2216e4738" class="bulleted-list"><li style="list-style-type:disc"><strong>Examples</strong>: Multitasking allows multiple processes to run concurrently; process isolation ensures that one process doesn&#x27;t interfere with another.</li></ul></li></ol><ol type="1" id="c4fcf42f-7efc-4ec5-a61b-466d18cab19f" class="numbered-list" start="3"><li><strong>Security and Access Control</strong>: The OS enforces security policies to protect system integrity and user data. It controls access to resources and ensures that only authorized users and applications can perform certain actions.<ul id="d44b1ff3-6fb2-4619-98f6-e193116e1339" class="bulleted-list"><li style="list-style-type:disc"><strong>Examples</strong>: User authentication, permission settings for files and directories.</li></ul></li></ol><ol type="1" id="63476c05-d6a8-4d74-a91c-1e4fb9d88d29" class="numbered-list" start="4"><li><strong>File and Storage Management</strong>: The OS organizes data storage and retrieval through a file system. It provides a structured way to store, retrieve, and manage data on storage devices.<ul id="a4b4eb67-d49c-4f86-b5d9-29a92e4d820e" class="bulleted-list"><li style="list-style-type:disc"><strong>Examples</strong>: File hierarchy, access control for files and directories.</li></ul></li></ol><ol type="1" id="679068b4-7c1a-41a4-8014-3ed6241abd50" class="numbered-list" start="5"><li><strong>Device Management</strong>: The OS manages device communication and operations. It provides drivers and interfaces for various hardware components, ensuring they work seamlessly with the system.<ul id="94eca55e-4b30-41fe-b021-d84300320f7a" class="bulleted-list"><li style="list-style-type:disc"><strong>Examples</strong>: Printer drivers, disk controllers.</li></ul></li></ol><p id="7d312262-fa43-435e-8424-8f9d67bc1e92" class="">By combining abstraction and management, the operating system provides a robust and user-friendly environment for both users and developers, hiding the complexities of the underlying hardware and ensuring efficient and secure system operation.</p></details></li></ul><ul id="7fc6bfe0-88a4-4b94-9d80-cb8d8dda14e4" class="toggle"><li><details open=""><summary>Goals of OS</summary><ul id="4bd9cf74-1e53-452d-9aba-d7ddb0a918d6" class="bulleted-list"><li style="list-style-type:disc">Max CPU utlization</li></ul><ul id="4c566673-35c6-4b93-8228-b990b82ac422" class="bulleted-list"><li style="list-style-type:disc">No Process starvation. Ex - P1 is taking long time but that should not block p2 and p3</li></ul><ul id="55211445-67f1-426d-933c-153e06ae44cb" class="bulleted-list"><li style="list-style-type:disc">High priority job execution.</li></ul></details></li></ul><ul id="beb8a28c-6b5c-41ed-a3d1-1bf15a1f113f" class="toggle"><li><details open=""><summary>Types of OS</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="843b6a10-9fc4-4448-b077-90bc68a18e60"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong><span style="border-bottom:0.05em solid">preemption</span></strong> is <strong>the act of temporarily interrupting an executing task, with the intention of resuming it at a later time</strong></div></figure><ul id="46b90fb1-45d9-4dca-8b13-b1485d461071" class="toggle"><li><details open=""><summary>Single process os</summary><p id="bbb80b0c-eb7f-4c82-b056-6baa179a0446" class="">one job at a time</p><p id="7aad53d3-f8f8-4914-9971-e14275937e11" class="">process starvation will take place</p><p id="909e528d-a806-4e4c-855d-7f6a61aaadc8" class="">no high priority </p><p id="a1743785-8802-4cf1-8d50-bd750dfe077a" class="">ex- MS DOS, </p></details></li></ul><ul id="c077756a-2179-4615-84fa-727aeeca02f6" class="toggle"><li><details open=""><summary>Batch processing os</summary><p id="76cd7d27-d43f-4549-bdfd-36a70933bfe5" class="">Jobs are batched or grouped and then send to os and then send to cpu. But the jobs inside batches will be processed sequentially only.</p><ul id="45aec6b7-ca71-4aa2-a862-18ceab3c0a1b" class="bulleted-list"><li style="list-style-type:disc"><strong>Description</strong>: Jobs are collected in batches and processed without user interaction. Suitable for tasks that require repetitive processing.</li></ul><ul id="a5c9af99-4c50-4df0-88d1-954f6bac3b0f" class="bulleted-list"><li style="list-style-type:disc"><strong>Example</strong>: Early mainframe systems like IBM&#x27;s OS/360.</li></ul><p id="29ace494-c15b-430e-9f0a-105dfe2924e9" class="">Max CPU utilisation not taking place</p><p id="6a8139e6-62fe-4f73-9aca-331a372af171" class="">Process starvation</p><p id="a4c28b2c-e2ce-4c7c-a2c9-9ce3734ec0f3" class="">Batch starvation</p><p id="d5aeb3c7-92ae-4839-b9ab-03752593bebc" class="">No high priority</p></details></li></ul><ul id="2c67bd1b-0da8-4f12-8bb7-5be6b6f38535" class="toggle"><li><details open=""><summary>Multi programming os</summary><ul id="d480506e-de7e-4bc1-bf5b-a97d9a6eec08" class="toggle"><li><details open=""><summary>Features</summary><ol type="1" id="eea7547f-abef-48e8-827c-83a4121f8bf4" class="numbered-list" start="1"><li>Need Single CPU for implementation.</li></ol><ol type="1" id="d7767a1d-8019-443f-959e-6acd9be4400e" class="numbered-list" start="2"><li>Context switch between process.</li></ol><ol type="1" id="9ff7af88-1785-46e6-bd27-1f3336d12eab" class="numbered-list" start="3"><li>Switching happens when current process undergoes waiting state.</li></ol><ol type="1" id="11e4675c-e0d9-432e-8a96-30d6ee704594" class="numbered-list" start="4"><li>CPU idle time is reduced.</li></ol><ol type="1" id="14ae96f4-5d7b-4661-8cb5-a6b8d28c7a2e" class="numbered-list" start="5"><li>High resource utilization.</li></ol><ol type="1" id="afbbcfb5-3531-4485-abbe-32902c84b6a5" class="numbered-list" start="6"><li>High Performance.</li></ol></details></li></ul><ul id="d38f55cb-6056-484f-88f1-e969a54c5a65" class="toggle"><li><details open=""><summary>How it works</summary><p id="07787c1e-bd49-4261-89a8-cc95520f4e5f" class="">CPU never remains idle till there are jobs to do</p><p id="2a147248-e68b-4630-92fa-0bb7733cd366" class="">While executing a process if its interuppted or its needed some I/O operation then it moves to next process and when the interruped process again  comesback , it completes the remaining operation of the process</p><hr id="62ea1959-2d3f-413c-a251-1fe086bd1c93"/><ul id="749805cf-568a-47b2-9c87-3602271b6429" class="bulleted-list"><li style="list-style-type:disc">In multiprogramming system, multiple programs are to be stored in memory and each program has to be given a specific portion of memory which is known as process. The operating system handles all these process and their states.</li></ul><ul id="c2aab5d6-b121-4936-8f56-68542097dc8d" class="bulleted-list"><li style="list-style-type:disc">Before the process undergoes execution, the operating system selects a ready process by checking which one process should udergo execution.</li></ul><ul id="9ddfc526-7c2b-4084-878a-eabf8b96f752" class="bulleted-list"><li style="list-style-type:disc">When the chosen process undergoes CPU execution, it might be possible that in between process need any input/output operation at that time process goes out of main memory for I/O operation and temporarily stored in secondary storage and CPU switches to next ready process</li></ul><ul id="a59f50fb-c945-40d6-96cb-bd8f86dc2d63" class="bulleted-list"><li style="list-style-type:disc">And when the process which undergoes for I/O operation comes again after completing the work, then CPU switches to this process. This switching is happening so fast and repeatedly that creates an illusion of simultaneous execution</li></ul></details></li></ul><ul id="ee84a4fc-be46-4bb9-8647-53622a9a7a0e" class="toggle"><li><details open=""><summary>Example of its working</summary><p id="6a733fbf-6778-4db4-9311-4c8c468aedcd" class="">In a multiprogramming operating system, multiple processes can be loaded into memory and executed concurrently. The OS switches between these processes, giving each one some CPU time, which creates the illusion of parallel execution.</p><p id="6a292a06-e69e-4b77-b6d7-495176dc3718" class="">Let&#x27;s consider your scenario with processes P1, P2, and P3:</p><ol type="1" id="0afc63c4-2b41-4dad-a4b3-543f9fd0ef52" class="numbered-list" start="1"><li>Initial state:<br/>P1, P2, and P3 are loaded into memory.<br/></li></ol><ol type="1" id="758be65d-a1c8-4701-ae89-d8b144a119c7" class="numbered-list" start="2"><li>Execution begins:<br/>The OS starts executing P1.<br/></li></ol><ol type="1" id="8353573a-6350-47d3-b244-8575a5195a71" class="numbered-list" start="3"><li>P1 completes or its time slice ends:<br/>The OS switches to P2.<br/></li></ol><ol type="1" id="ac95babc-5a9f-4759-b810-43a8a9282240" class="numbered-list" start="4"><li>Interruption occurs during P2&#x27;s execution:<ul id="09cb68bf-7db8-4a39-b1dc-22c1dd2f402a" class="bulleted-list"><li style="list-style-type:disc">P2&#x27;s state is saved (program counter, registers, etc.).</li></ul><ul id="333a2457-ab0b-4139-86d9-b144f998ead2" class="bulleted-list"><li style="list-style-type:disc">P2 is moved to a waiting state.</li></ul><ul id="545832b0-899c-44c2-8338-934eac51ef89" class="bulleted-list"><li style="list-style-type:disc">The OS handles the interruption.</li></ul></li></ol><ol type="1" id="9e925d24-7d23-492c-bd2d-559ab6bd32df" class="numbered-list" start="5"><li>After handling the interruption:<br/>The OS switches to P3, as P2 is now waiting.<br/></li></ol><ol type="1" id="dcbfe7d8-2f01-47dd-97ca-d447ec98e281" class="numbered-list" start="6"><li>During P3&#x27;s execution, P2 becomes ready:<ul id="465b56dc-c1b1-4cf7-b159-4f48769d6d6c" class="bulleted-list"><li style="list-style-type:disc">This could happen if P2&#x27;s I/O operation completes or its wait condition is satisfied.</li></ul><ul id="193ec5f9-3d39-461d-a59c-28a7266221de" class="bulleted-list"><li style="list-style-type:disc">P2 moves from the waiting state to the ready state.</li></ul></li></ol><ol type="1" id="cc701291-cdde-402f-928f-7fdd2d6c1ae0" class="numbered-list" start="7"><li>P3 continues executing:<br/>The OS doesn&#x27;t immediately switch back to P2. It allows P3 to continue until its time slice ends or it voluntarily yields the CPU.<br/></li></ol><ol type="1" id="026330dd-9e08-46c7-9b9c-7555af835d6f" class="numbered-list" start="8"><li>P3&#x27;s time slice ends:<br/>The OS performs a context switch.<br/></li></ol><ol type="1" id="0bdf967f-7e2d-46f5-809a-790eb3574092" class="numbered-list" start="9"><li>Next process selection:<br/>The OS scheduler decides which process to run next. It could choose P1, P2, or P3, depending on the scheduling algorithm. Let&#x27;s assume it chooses P2 since it just became ready.<br/></li></ol><ol type="1" id="1776bb50-7877-4bc5-b657-0cd3b486d6aa" class="numbered-list" start="10"><li>Execution continues:<br/>P2 resumes execution from where it left off before the interruption.<br/></li></ol><p id="58d8f3fe-d8d3-4c72-8a2f-3321319473d4" class="">This cycle continues, with the OS switching between the processes based on its scheduling algorithm, interrupts, and the processes&#x27; states.</p></details></li></ul><ul id="54b4dd4c-e44a-48e4-9a18-aa00ddbf5473" class="toggle"><li><details open=""><summary>Data structures used</summary><h3 id="721e7a73-7189-474e-99b8-3fd083774050" class="">Process Control Block(PCB)</h3><ul id="d88b75cd-85ae-423f-8da7-e585fe8db190" class="bulleted-list"><li style="list-style-type:disc">The PCB is a data structure maintained by the operating system for each process.</li></ul><ul id="412165ac-3c09-4973-88ec-809d6aa9d25b" class="bulleted-list"><li style="list-style-type:disc">OS saves current process’s state inside PCB during context switch and also loads the state of the next process from its PCB.</li></ul><ul id="c1d8e327-10c6-4a65-ae00-f6e9f0fc47dd" class="bulleted-list"><li style="list-style-type:disc">Information stored<ul id="fd4dff21-f926-4abc-92ff-ada5ef93a4f8" class="bulleted-list"><li style="list-style-type:circle">Process ID (PID): Unique identifier for the process</li></ul><ul id="bd499813-33ad-421b-bbfa-cd2fca21833b" class="bulleted-list"><li style="list-style-type:circle">Process State: Running, Ready, Waiting, etc.</li></ul><ul id="8028a0c1-1103-4393-b9b2-d7fa7a2e7751" class="bulleted-list"><li style="list-style-type:circle">Program Counter: Address of the next instruction to be executed</li></ul><ul id="f96da559-b225-490a-8a01-162505958026" class="bulleted-list"><li style="list-style-type:circle">CPU Registers: Contents of CPU registers</li></ul><ul id="00cd8f05-7923-4cc0-8334-3cca84f72f4d" class="bulleted-list"><li style="list-style-type:circle">CPU Scheduling Information: Priority, scheduling queue pointers</li></ul><ul id="2ca1c522-61a5-4302-b8b4-d55278013308" class="bulleted-list"><li style="list-style-type:circle">Memory Management Information: Base and limit registers, page tables, or segment tables</li></ul><ul id="942a7bdf-19bc-4434-a2a0-78fc931ba9da" class="bulleted-list"><li style="list-style-type:circle">Accounting Information: CPU used, clock time elapsed since start, time limits</li></ul><ul id="e76d9064-0a8a-4dc0-bc3a-a05b3b713a09" class="bulleted-list"><li style="list-style-type:circle">I/O Status Information: List of I/O devices allocated to the process, list of open files</li></ul></li></ul><h3 id="59bdad96-eb0f-4028-8e5e-32e46e8203e2" class="">Ready Queue:</h3><ul id="c80ad8e0-bcb9-474d-b3e7-2d3e3d8b3e16" class="bulleted-list"><li style="list-style-type:disc">Typically implemented as a linked list or a priority queue</li></ul><ul id="23183735-a15a-43d9-ac4c-ac4a37473bf9" class="bulleted-list"><li style="list-style-type:disc">Contains PCBs of all processes in the ready state</li></ul><ul id="ec7adc8c-792e-42a5-9a64-182b88d95138" class="bulleted-list"><li style="list-style-type:disc">The scheduler selects the next process to run from this queue</li></ul><h3 id="dd10042c-93b3-4af0-96e1-579a06e276c8" class="">Wait Queues:</h3><ul id="13006113-8c70-4393-8946-5e068ef47524" class="bulleted-list"><li style="list-style-type:disc">Also typically implemented as linked lists</li></ul><ul id="6659e701-aaa7-4ebd-ba14-cb7c5110db6a" class="bulleted-list"><li style="list-style-type:disc">Separate queues for each I/O device or system resource</li></ul><ul id="a5989273-1b1d-403d-be29-0bf685ed6ded" class="bulleted-list"><li style="list-style-type:disc">Processes waiting for a specific resource are placed in the corresponding wait queue</li></ul><h3 id="11bd6604-9cb5-4cb5-9620-668e6b9c89a0" class="">Run Queue:</h3><ul id="b4172cf4-667d-4cb2-b70e-229e2f2cc836" class="bulleted-list"><li style="list-style-type:disc">In some systems, a separate queue for the currently running process(es)</li></ul><ul id="0669fa65-68c3-4c85-ada0-cef74025efba" class="bulleted-list"><li style="list-style-type:disc">In multi-processor systems, there might be multiple run queues</li></ul></details></li></ul><p id="4c2f1c6b-f74d-462d-9ddc-93184ab13b5e" class="">
</p></details></li></ul><ul id="8ded7c4b-32d8-457b-8177-0124cf0d8ace" class="toggle"><li><details open=""><summary>Multi tasking os (Time sharing os) → Logical extension of Multiprogramming OS</summary><p id="b054d6c8-2d21-4dbc-b14c-d5956fa5e38e" class="">A logical extension of multi programming os. A multitasking OS is designed to run multiple programs concurrently, giving the illusion that several tasks are executing simultaneously, even on a single CPU core.</p><p id="5f1f57b0-2f1d-47ba-86b6-0fdae95a1c2b" class="">It is having time sharing.</p><p id="228b5830-32e8-44c8-a8da-6b716ebfe3a8" class="">Generally we do multi tasking in our system like editing docs, playing music,etc</p><p id="18ba47e9-1cdf-4d8e-b59b-a40649d6fd35" class="">Basically all the programs or jobs running are assigned some time quantum and </p><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">Concept of Time quantum</summary><div class="indented"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="9287afa6-7c82-4bf1-a44b-8b98075b0b21"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">It is kind of an unit. Like 3 time quantum.</div></figure><ul id="0fa0a447-b83b-408d-a66b-78a725e4b054" class="bulleted-list"><li style="list-style-type:disc">Time quantum is a fundamental concept in multitasking operating systems, particularly those that use Round Robin scheduling or other time-sharing algorithms</li></ul><ul id="3c2a8414-c0d1-446c-a1cf-5a969115912e" class="bulleted-list"><li style="list-style-type:disc">A time quantum, also known as a time slice or CPU quantum, is the maximum amount of time allocated to a process for execution before it is preempted and another process is given a chance to run.</li></ul><ul id="9238ba1b-c084-4f8b-bebf-5065900b29b0" class="bulleted-list"><li style="list-style-type:disc">Purpose:<ul id="a2ca3bf3-ece6-4c47-9225-54b90decb4ed" class="bulleted-list"><li style="list-style-type:circle">Ensures fair distribution of CPU time among processes</li></ul><ul id="dcf9c955-491c-4d00-b5c4-e78c880069d1" class="bulleted-list"><li style="list-style-type:circle">Prevents a single process from monopolizing the CPU that it is taking longer duration to execute and other processes are not yet started</li></ul><ul id="990e1b19-fc35-46d5-861c-2f5d84c32c65" class="bulleted-list"><li style="list-style-type:circle">Enables the illusion of parallel execution in a single-core system</li></ul></li></ul><ul id="3e5f8972-0231-4886-a9af-01b68adb2f44" class="bulleted-list"><li style="list-style-type:disc">Typical duration:<ul id="173e29f9-2546-41a5-b02a-955c0d36feb4" class="bulleted-list"><li style="list-style-type:circle">Usually ranges from about 10 to 100 milliseconds</li></ul><ul id="51bef2af-6e68-4dd7-a801-207ad79d21a1" class="bulleted-list"><li style="list-style-type:circle">The exact value depends on the system and its requirements</li></ul></li></ul><ul id="09eea025-8ab9-472e-a9b6-59b8aed6fd9d" class="bulleted-list"><li style="list-style-type:disc">Effects of time quantum size:<ul id="309e5f9e-beb3-41c2-bc66-47ec3ddbbc39" class="bulleted-list"><li style="list-style-type:circle">Too small: Leads to excessive context switching, reducing overall efficiency</li></ul><ul id="58d24b6f-b107-4ba3-9958-f62cb6b36945" class="bulleted-list"><li style="list-style-type:circle">Too large: Reduces responsiveness, especially for interactive processes</li></ul></li></ul><ul id="87bc67cc-f31e-4926-bc29-940db20a603f" class="bulleted-list"><li style="list-style-type:disc">Implementation:<ul id="a98f5217-2af1-4c39-9eec-97e4f02c3947" class="bulleted-list"><li style="list-style-type:circle">Often managed using a programmable interval timer</li></ul><ul id="fb1b2c89-52da-4e3f-8ebc-518c82a1ff15" class="bulleted-list"><li style="list-style-type:circle">When a time quantum expires, it triggers an interrupt</li></ul></li></ul><ul id="de2f5bbd-8f1a-48ba-b4d7-e9607d9b00dc" class="bulleted-list"><li style="list-style-type:disc">Process behavior:<ul id="f9910386-1cbd-4cdf-8311-356289b4c787" class="bulleted-list"><li style="list-style-type:circle">If a process completes before its time quantum expires, it voluntarily releases the CPU</li></ul><ul id="418609aa-1328-4161-b3a7-a9dd7eac815c" class="bulleted-list"><li style="list-style-type:circle">If a process exceeds its time quantum, it is preempted and moved to the end of the ready queue</li></ul></li></ul><hr id="1db51722-dd13-48c8-ac5f-545963268342"/><ol type="1" id="7536f71c-ebe1-4ba6-a565-545c954fe26f" class="numbered-list" start="1"><li>Responsiveness: Shorter time quanta lead to better responsiveness for interactive processes, as each process gets frequent chances to run.</li></ol><ol type="1" id="1f4dd912-ec7e-443a-8f26-d210f8f89cd8" class="numbered-list" start="2"><li>Context switching overhead: Every time a process is preempted, a context switch occurs. More frequent context switches (due to shorter time quanta) increase overhead.</li></ol><ol type="1" id="ff56c34e-da06-4e62-abbe-a72202951df4" class="numbered-list" start="3"><li>CPU utilization: The time quantum should be significantly larger than the time required for a context switch to ensure efficient CPU utilization.</li></ol><ol type="1" id="556c80e9-b9cf-49d3-b259-ca4edd55a2cc" class="numbered-list" start="4"><li>Process characteristics: I/O-bound processes often don&#x27;t use their entire time quantum, voluntarily yielding the CPU when they initiate I/O operations. CPU-bound processes typically use their entire quantum before being preempted.</li></ol><ol type="1" id="a707aa31-0bb1-498a-9c43-5f9694484034" class="numbered-list" start="5"><li>Starvation prevention: Round Robin scheduling with fixed time quanta ensures that no process can starve, as each will eventually get its turn to execute.</li></ol><p id="92ab9093-2499-42af-bbed-e4cb4f311bb4" class="">The choice of an appropriate time quantum is crucial for system performance and depends on factors like the nature of processes (I/O-bound vs. CPU-bound), system responsiveness requirements, and the overhead of context switching in the particular hardware and OS environment.</p></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">How time quantum is used</summary><div class="indented"><ul id="b80cf179-051f-47dd-bf6a-b1aebab94a1b" class="bulleted-list"><li style="list-style-type:disc">We have three processes: P1, P2, and P3</li></ul><ul id="49580cb3-4615-4c17-8028-4911db0d0a4e" class="bulleted-list"><li style="list-style-type:disc">The time quantum is set to 4 units</li></ul><ul id="e33e75f5-0a2a-49b2-8d8c-a05622155758" class="bulleted-list"><li style="list-style-type:disc">Each process gets to run for 4 time units before being preempted</li></ul><ul id="27a7a287-8c5c-4f84-b816-bbe2ef06b082" class="bulleted-list"><li style="list-style-type:disc">The cycle repeats, giving each process a fair share of CPU time</li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">Premptive vs Cooperative Multitasking/context switching</summary><div class="indented"><ul id="bcb56659-6960-48fb-a330-5415002f1c11" class="bulleted-list"><li style="list-style-type:disc"><strong>Pre-emptive Multi-Tasking Operating System: </strong><ul id="e53b8529-073f-47fa-8dac-fe512de99225" class="bulleted-list"><li style="list-style-type:circle">In pre-emptive multitasking, the operating system can initiate a context switching from the running process to another process. </li></ul><ul id="b8221918-a4bc-4dc6-8328-efe6f86c8ac0" class="bulleted-list"><li style="list-style-type:circle">In other words, the operating system allows stopping the execution of the currently running process and allocating the CPU to some other process. </li></ul><ul id="a4a71e0a-27ae-4356-9e92-2f2d6bb92702" class="bulleted-list"><li style="list-style-type:circle">The OS uses some criteria to decide for how long a process should execute before allowing another process to use the operating system. The mechanism of taking control of the operating system from one process and giving it to another process is called pre-emption. </li></ul><ul id="7e3da840-f130-4aad-a8c0-9b80293728c8" class="bulleted-list"><li style="list-style-type:circle">Here are some Examples <strong><a href="https://www.geeksforgeeks.org/introduction-to-unix-system/">UNIX</a></strong>, Windows 95, Windows NT operating system.</li></ul></li></ul><ul id="2cf43359-ca69-4b51-a452-01cd6dba602b" class="bulleted-list"><li style="list-style-type:disc"><strong>Cooperative Multi-Tasking Operating System: </strong><ul id="59f09442-2c44-4370-9594-952b95ff45c6" class="bulleted-list"><li style="list-style-type:circle">Non-pre-emptive Multi-Tasking Operating System is also known as cooperative multitasking, this operating system never initiates context switching from the running process to another process. </li></ul><ul id="521ec1e1-a80e-4574-8ce3-17c31b8874d8" class="bulleted-list"><li style="list-style-type:circle">A context switch occurs only when the processes voluntarily yield control periodically or when idle or logically blocked to allow multiple applications to execute simultaneously. </li></ul><ul id="9ee1f41b-f151-4314-9e52-1427ee639bcb" class="bulleted-list"><li style="list-style-type:circle">Also, in this multitasking, all the processes cooperate for the scheduling scheme to work. </li></ul><ul id="e583c5e3-519a-49f7-8d26-a676acc677c6" class="bulleted-list"><li style="list-style-type:circle">Example – Macintosh OS version 8.0-9.2.2 and Windows 3.x operating system.</li></ul></li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">How it works</summary><div class="indented"><ul id="75a4e037-9793-4b5f-a6ea-7db936abb4b2" class="bulleted-list"><li style="list-style-type:disc">The CPU is managed by the Scheduler.</li></ul><ul id="806114a3-33f8-4ace-9313-9b43d041e6c4" class="bulleted-list"><li style="list-style-type:disc">The Scheduler decides which process from the Ready Queue gets to run next.</li></ul><ul id="1f362e89-f239-430d-a762-2e419f3cb935" class="bulleted-list"><li style="list-style-type:disc">The Running Process executes until its time quantum expires or it makes an I/O request.</li></ul><ul id="788f8d26-553f-45d2-ac94-8cf2e85ad54a" class="bulleted-list"><li style="list-style-type:disc">If the time quantum expires, the process goes back to the Ready Queue.</li></ul><ul id="904939b0-b5d9-408a-a5de-10a285288a51" class="bulleted-list"><li style="list-style-type:disc">If the process makes an I/O request, it moves to the I/O Wait Queue.</li></ul><ul id="55153353-734c-4346-9c88-acf88770a21e" class="bulleted-list"><li style="list-style-type:disc">When I/O is complete, the process moves back to the Ready Queue.</li></ul></div></details><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="34496336-b484-49d1-9032-5705b262a52e" class="code"><code class="language-Mermaid">graph TD
    A[CPU] --&gt; B[Scheduler]
    B --&gt; C[Running Process]
    B --&gt; D[Ready Queue]
    B --&gt; E[I/O Wait Queue]
    C --&gt;|Time Quantum Expired| D
    C --&gt;|I/O Request| E
    D --&gt;|Selected to Run| C
    E --&gt;|I/O Complete| D</code></pre></details></li></ul><ul id="8443ae00-0ff6-43ae-9d78-1e5cb7a633e8" class="toggle"><li><details open=""><summary>Multi processing os</summary><p id="382ad0d1-8894-4389-8fc2-e5a4328ec08d" class="">Contains all features of multi tasking os along with multiple CPUs(cores)</p><ul id="87fed226-73e8-4e50-9c04-d5c188702549" class="toggle"><li><details open=""><summary>Each processors implementing multi tasking</summary><p id="11fdf2f5-d195-451c-81a3-74021e6f481d" class="">In a multiprocessing operating system, each individual processor typically still implements multitasking. This creates a two-level structure of concurrency. Let&#x27;s break this down:</p><ol type="1" id="6beef577-6733-405d-8456-2aea55338f6d" class="numbered-list" start="1"><li>System-level multiprocessing:<ul id="b9d03fec-8157-494f-a632-5916ef945d4d" class="bulleted-list"><li style="list-style-type:disc">Multiple processors working simultaneously</li></ul><ul id="359929f0-a321-41a3-b20f-6afbe457ac37" class="bulleted-list"><li style="list-style-type:disc">True parallel execution of processes</li></ul></li></ol><ol type="1" id="38850f41-eafe-4695-9713-b1cbc2859198" class="numbered-list" start="2"><li>Processor-level multitasking:<ul id="2427341a-c85d-4ffa-acc9-13595bf48f5c" class="bulleted-list"><li style="list-style-type:disc">Each processor switches between multiple tasks</li></ul><ul id="d7076574-9a96-42d1-829d-d69f860acb01" class="bulleted-list"><li style="list-style-type:disc">Time-sharing on individual processors</li></ul></li></ol><p id="48ebe412-740f-436f-9aea-7b89f205d80b" class="">Here&#x27;s how this works in practice:</p><ol type="1" id="a3fda4fa-cc9f-4a6d-8599-eaccf56c03ff" class="numbered-list" start="1"><li>Multiple processors:<br/>The system has several processors (or cores) that can run independently.<br/></li></ol><ol type="1" id="5f2578a8-92fc-4017-a90e-2b6125a6dab9" class="numbered-list" start="2"><li>Global scheduling:<br/>The operating system&#x27;s global scheduler distributes processes across these processors.<br/></li></ol><ol type="1" id="043cbe93-48cc-466c-b652-e207a73ac151" class="numbered-list" start="3"><li>Local scheduling:<br/>Each processor then performs its own local scheduling, switching between the tasks assigned to it.<br/></li></ol><ol type="1" id="dde978f5-48ee-46c4-8958-7a39e8a59c8b" class="numbered-list" start="4"><li>Time quantum:<br/>Each processor still uses time quanta to switch between its assigned tasks.<br/></li></ol><ol type="1" id="5ba8094b-a8a5-4c80-b18a-50887c9be3aa" class="numbered-list" start="5"><li>Context switching:<br/>Context switches occur both when moving between processors and when switching tasks on a single processor.<br/></li></ol></details></li></ul><ul id="89a1db99-76ea-4718-9d0a-5f4e31b6c42a" class="toggle"><li><details open=""><summary>how it works</summary><ul id="7fcb0d1a-89b6-4da8-ad89-4a75cca06c2c" class="bulleted-list"><li style="list-style-type:disc">The Global Scheduler distributes tasks to multiple processors.</li></ul><ul id="1a49f8fb-c934-4ace-b286-f88ec86dcaf7" class="bulleted-list"><li style="list-style-type:disc">Each processor can access the Shared Memory.</li></ul><ul id="912fe4b7-b4d6-463f-a91e-9a40ec154d71" class="bulleted-list"><li style="list-style-type:disc">The Cache Coherence Manager ensures data consistency across processor caches.</li></ul><ul id="f1eea332-59a6-4641-831a-cc9001df8b93" class="bulleted-list"><li style="list-style-type:disc">The Ready Queue holds processes waiting to be executed, which can be assigned to any available processor.</li></ul></details></li></ul><ul id="eac5d87b-3e4d-43da-a6cc-d55fca74aee1" class="toggle"><li><details open=""><summary>types</summary><p id="0b5cb135-3832-49c5-bb5c-346b1bf2fdc9" class="">Symmetric Operating System:</p><ol type="1" id="fa73240a-b6fe-48dc-acc6-4969c7d3be5d" class="numbered-list" start="1"><li>Definition:<br/>A symmetric operating system is one where all instances of the operating system are identical and have equal responsibilities and capabilities.<br/></li></ol><ol type="1" id="04b784cc-1762-4675-a0f4-6ed236363aa0" class="numbered-list" start="2"><li>Key characteristics:<ul id="a86dcd8a-2f39-4a50-8175-b9b8459d9459" class="bulleted-list"><li style="list-style-type:disc">All CPUs run identical copies of the OS</li></ul><ul id="e1f4dc9f-18f1-4d64-bcbc-8bb546beda33" class="bulleted-list"><li style="list-style-type:disc">Any CPU can perform any task</li></ul><ul id="3cbe7cdf-9dd5-48b4-b77d-560b104c6a53" class="bulleted-list"><li style="list-style-type:disc">All CPUs share device interrupts</li></ul><ul id="a5be531a-41fe-49ac-805f-cdf3a364a65e" class="bulleted-list"><li style="list-style-type:disc">A single, unified memory space is shared among all CPUs</li></ul></li></ol><ol type="1" id="66010f98-d7eb-4b77-8374-899b216e8721" class="numbered-list" start="3"><li>Typical use cases:<ul id="d847ef36-eac7-49be-b2d6-265fb6c29b60" class="bulleted-list"><li style="list-style-type:disc">Most modern desktop and server operating systems (Windows, Linux, macOS)</li></ul><ul id="ad8b7139-1fe4-4402-a52f-fe9bb9d22556" class="bulleted-list"><li style="list-style-type:disc">General-purpose computing environments</li></ul></li></ol><ol type="1" id="5caa3c12-138b-45ac-aadb-e9a5af044a00" class="numbered-list" start="4"><li>Advantages:<ul id="0b3269d0-1d92-489c-b24d-b63763ec3ccd" class="bulleted-list"><li style="list-style-type:disc">Simpler design and implementation</li></ul><ul id="ce096ff5-45d6-4577-9e31-032ccfe19d4e" class="bulleted-list"><li style="list-style-type:disc">Better load balancing</li></ul><ul id="758d872e-2457-4c00-96b1-a6467e20bcda" class="bulleted-list"><li style="list-style-type:disc">More efficient use of resources</li></ul><ul id="550e7e07-cf20-4f7c-adcf-3f7e60bf2726" class="bulleted-list"><li style="list-style-type:disc">Easier to scale</li></ul></li></ol><ol type="1" id="4cb96174-7626-480c-8a8a-8754374f2879" class="numbered-list" start="5"><li>Challenges:<ul id="0651dbd1-3f26-412d-b2d0-e0d6f3c9f00d" class="bulleted-list"><li style="list-style-type:disc">Potential for contention in accessing shared resources</li></ul><ul id="bde698c9-e0e0-4532-96e4-bf45353b743f" class="bulleted-list"><li style="list-style-type:disc">Complexity in ensuring synchronization</li></ul></li></ol><p id="504da2f7-624d-4dfb-ac4e-9af82f4e04e0" class="">Asymmetric Operating System:</p><ol type="1" id="e6e8a8b0-cbbe-448c-aca0-66127c43e6bd" class="numbered-list" start="1"><li>Definition:<br/>An asymmetric operating system is one where different instances or components of the OS have distinct roles, responsibilities, or privileges.<br/></li></ol><ol type="1" id="29e760a3-4ea2-42cb-bbf7-6cbf30800724" class="numbered-list" start="2"><li>Key characteristics:<ul id="d1361167-0731-44d5-90d8-d185e646b2d2" class="bulleted-list"><li style="list-style-type:disc">Different CPUs may run different versions or components of the OS</li></ul><ul id="078809a0-8779-44d9-b936-42624c1c1ce6" class="bulleted-list"><li style="list-style-type:disc">Specific tasks are often assigned to specific processors</li></ul><ul id="9669456c-f8f9-4d72-8092-89f82b942ee1" class="bulleted-list"><li style="list-style-type:disc">One processor (often called the master) may control the others</li></ul><ul id="8f99b66c-79e1-42dd-9132-cf35a19aabb2" class="bulleted-list"><li style="list-style-type:disc">Memory may be partitioned or managed differently for different processors</li></ul></li></ol><ol type="1" id="7c971abe-17fa-4835-8bbc-a80199d71809" class="numbered-list" start="3"><li>Typical use cases:<ul id="87390b1d-5421-4e85-ae60-95add5896a26" class="bulleted-list"><li style="list-style-type:disc">Some real-time operating systems</li></ul><ul id="b96c0a07-87bd-4f10-a349-b20652cbf74d" class="bulleted-list"><li style="list-style-type:disc">Specialized embedded systems</li></ul><ul id="222fcd2a-ef56-47e6-936e-6a4d71845f77" class="bulleted-list"><li style="list-style-type:disc">Some high-performance computing scenarios</li></ul></li></ol><ol type="1" id="30d30fd9-19ac-4e21-8770-b3d5919b83b0" class="numbered-list" start="4"><li>Advantages:<ul id="538caf0f-e668-402d-bbc4-5281ce819596" class="bulleted-list"><li style="list-style-type:disc">Can be optimized for specific hardware or tasks</li></ul><ul id="73fe573f-8c01-4a3f-889f-ca45cb73c712" class="bulleted-list"><li style="list-style-type:disc">Potentially better for real-time or critical systems</li></ul><ul id="efa50521-bd5b-433a-a9e2-0ef966592621" class="bulleted-list"><li style="list-style-type:disc">Can provide stronger isolation between different system components</li></ul></li></ol><ol type="1" id="a7ed22be-73db-4af8-8361-7811b5988456" class="numbered-list" start="5"><li>Challenges:<ul id="e10f0d2d-f3ca-422b-8118-d509bf43eb74" class="bulleted-list"><li style="list-style-type:disc">More complex to design and implement</li></ul><ul id="fa90236d-9c0f-4eed-83f0-8983cc37960a" class="bulleted-list"><li style="list-style-type:disc">Can be less flexible and harder to scale</li></ul><ul id="b1fae41b-df90-4c16-ab5b-0478d30e3c31" class="bulleted-list"><li style="list-style-type:disc">May lead to uneven resource utilization</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="19c66331-b105-4971-86e4-becbf7a46293" class="code"><code class="language-Mermaid">graph TD
    subgraph Symmetric OS
    CPU1[CPU 1] --&gt; OS1[OS Instance]
    CPU2[CPU 2] --&gt; OS1
    CPU3[CPU 3] --&gt; OS1
    CPU4[CPU 4] --&gt; OS1
    OS1 --&gt; SM[Shared Memory]
    OS1 --&gt; R[Resources]
    end

    subgraph Asymmetric OS
    ACPU1[Master CPU] --&gt; MOS[Master OS]
    ACPU2[CPU 2] --&gt; SOS1[Slave OS 1]
    ACPU3[CPU 3] --&gt; SOS2[Slave OS 2]
    ACPU4[CPU 4] --&gt; SOS3[Slave OS 3]
    MOS --&gt; M1[Memory 1]
    SOS1 --&gt; M2[Memory 2]
    SOS2 --&gt; M3[Memory 3]
    SOS3 --&gt; M4[Memory 4]
    MOS --&gt; AR[All Resources]
    SOS1 --&gt; R1[Resource 1]
    SOS2 --&gt; R2[Resource 2]
    SOS3 --&gt; R3[Resource 3]
    end</code></pre></li></ol></details></li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0a0cad85-b117-4210-9307-14c7e016ce9c" class="code"><code class="language-Mermaid">graph TD
    S[Global Scheduler] --&gt; P1[Processor 1]
    S --&gt; P2[Processor 2]
    S --&gt; P3[Processor 3]
    S --&gt; P4[Processor 4]
    P1 --&gt; SM[Shared Memory]
    P2 --&gt; SM
    P3 --&gt; SM
    P4 --&gt; SM
    SM --&gt; C[Cache Coherence Manager]
    S --&gt; RQ[Ready Queue]
    RQ --&gt; P1
    RQ --&gt; P2
    RQ --&gt; P3
    RQ --&gt; P4</code></pre></details></li></ul><ul id="d0d3fa40-7a2b-4704-b7c1-2d71b276197a" class="toggle"><li><details open=""><summary>ditributed os</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="5f0373da-2d6b-46a0-a145-c4e56fc8bc15"><div style="font-size:1.5em"><span class="icon">👉</span></div><div style="width:100%">Important → <a href="https://www.geeksforgeeks.org/what-is-a-distributed-operating-system/">https://www.geeksforgeeks.org/what-is-a-distributed-operating-system/</a><br/><br/>ex → Cloud platforms, cdns, blockchain networks,etc<br/></div></figure><p id="0021cf05-1d07-4941-9c52-411463846521" class="">In a Distributed Operating System, multiple CPUs are utilized, but for end-users, it appears as a typical centralized operating system. It enables the sharing of various resources such as CPUs, disks, network interfaces, nodes, and computers across different sites, thereby expanding the available data within the entire system.</p><p id="7b237fba-66a6-41d4-83f8-4692c765c0d0" class=""> They handle jobs which are serviced by multiple CPUs</p><p id="8fd27ca3-9f28-41ed-b086-04de7ad419fd" class="">The concept of a distributed operating system actually encompasses both aspects - it&#x27;s an operating system design approach that is closely tied to a particular system architecture. Let me break this down:</p><p id="ca1c3b15-81f8-4cca-b27a-704609e8f4f2" class="">Distributed Operating System:</p><ol type="1" id="b04e9082-691a-48d0-af2f-98187ee402a0" class="numbered-list" start="1"><li>Definition:<br/>A distributed operating system is an operating system that manages a collection of independent, networked computers and makes them appear to the user as a single coherent system.<br/></li></ol><ol type="1" id="bc734415-3224-4e00-b8ba-3276eddb2a94" class="numbered-list" start="2"><li>OS Aspect:<ul id="2264e635-7769-4f5b-9bb4-4a32c75b67f0" class="bulleted-list"><li style="list-style-type:disc">It&#x27;s a type of operating system design</li></ul><ul id="8b7f0525-d8c3-4aab-8ef1-9ab990b9457c" class="bulleted-list"><li style="list-style-type:disc">Provides unified access to resources spread across multiple machines</li></ul><ul id="51cd9a37-9d88-4421-9623-29441b0fce50" class="bulleted-list"><li style="list-style-type:disc">Manages process scheduling, memory allocation, file systems, and other OS tasks across distributed hardware</li></ul></li></ol><ol type="1" id="7eee806d-96f8-43a7-b4b4-ac522d012452" class="numbered-list" start="3"><li>Architectural Aspect:<ul id="fdadb7e9-3984-4e61-9bb2-6a705bfe620f" class="bulleted-list"><li style="list-style-type:disc">Relies on a distributed system architecture</li></ul><ul id="56ee2d38-29da-4144-92c0-bb8dc4fa68d6" class="bulleted-list"><li style="list-style-type:disc">Requires network infrastructure to connect multiple computers</li></ul><ul id="3552fdfc-1f64-4eaa-bb97-784e3a515a01" class="bulleted-list"><li style="list-style-type:disc">Involves design decisions about how to distribute processing, storage, and other resources</li></ul></li></ol></details></li></ul><ul id="69d86821-6ef6-4068-beb0-34a26b561142" class="toggle"><li><details open=""><summary>realtime os</summary><p id="454257e9-eb6d-4355-b17d-4a2e50af4641" class="">Real-time<strong> operating systems (RTOS)</strong> are used in environments where a large number of events, mostly external to the computer system, must be accepted and processed in a short time or within certain deadlines. such applications are industrial control, telephone switching equipment, flight control, and real-time simulations.</p><p id="55177e78-7772-484a-8861-3051362b715d" class="">With an RTOS, the processing time is measured in tenths of seconds. This system is time-bound and has a fixed deadline. The processing in this type of system must occur within the specified constraints. Otherwise, This will lead to system failure.</p><h1 id="b388ab5b-37f0-476e-9618-d2ecba1b8e84" class="">Uses of RTOS</h1><ul id="9178c509-7624-494a-9d24-461756227121" class="bulleted-list"><li style="list-style-type:disc">Defense systems like <strong><a href="https://www.geeksforgeeks.org/radar/">RADAR</a></strong>.</li></ul><ul id="42f2b99c-29c0-4069-8623-c34d8d34dfff" class="bulleted-list"><li style="list-style-type:disc">Air traffic control system.</li></ul><ul id="1ecad013-0482-490e-af35-2ead60c622c9" class="bulleted-list"><li style="list-style-type:disc">Networked multimedia systems.</li></ul><ul id="7c28d6cf-3ee2-40b2-8535-9eb34e9c7d38" class="bulleted-list"><li style="list-style-type:disc">Medical devices like pacemakers.</li></ul><ul id="460ade72-6be8-4343-a29d-1b289b020a25" class="bulleted-list"><li style="list-style-type:disc">Stock trading applications.</li></ul></details></li></ul><hr id="0566ce60-88a1-4e92-b766-9379b5bf2116"/><ul id="177dae90-2269-47bd-bd38-0235680c67cc" class="toggle"><li><details open=""><summary>using single cpu vs multi cpus</summary><ul id="749bb37f-b9a3-4004-8012-09f5ef405d01" class="bulleted-list"><li style="list-style-type:disc">True parallelism: Multiple processes can execute simultaneously on different processors.</li></ul><ul id="b5cc4868-a602-4a89-b1f8-87e6e559a366" class="bulleted-list"><li style="list-style-type:disc">Increased complexity in scheduling: The OS must decide not just when to run a process, but on which processor.</li></ul><ul id="c75ddcbb-829d-4321-a1e9-c418ab7b5a26" class="bulleted-list"><li style="list-style-type:disc">Memory management: Shared memory systems require careful management to prevent conflicts.</li></ul><ul id="b891a448-a76a-4e2e-9814-cb3b44bc4a0c" class="bulleted-list"><li style="list-style-type:disc">Scalability: Multiprocessing systems can often scale performance by adding more processors, up to certain limits.</li></ul><ul id="813f6724-7e50-4dbe-8c2c-543500f4d58c" class="bulleted-list"><li style="list-style-type:disc">Resource contention: Managing access to shared resources (like I/O devices) becomes more complex.</li></ul></details></li></ul></details></li></ul><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">multi tasking vs multi threading vs multi processing (proper explanation)</summary><div class="indented"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="56a374f8-a434-4a4e-938c-70679485f184"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">To understand from scratch , read it completely<br/>Other wise read the conclusion<br/></div></figure><figure id="a3bebfe2-2e58-438a-add0-4a0508062fdc" class="image"><a href="https://miro.medium.com/v2/resize:fit:620/1*syyujsSST2CeIIbIdFWVCg.png"><img style="width:620px" src="https://miro.medium.com/v2/resize:fit:620/1*syyujsSST2CeIIbIdFWVCg.png"/></a></figure><p id="9122d510-6477-4d0f-a4ff-c25fb7716f20" class="">Computers today are very smart and can perform multiple operations at once. This ability of computers to run multiple tasks at the same time is called <strong>Multitasking</strong>.</p><p id="6304e447-bdc7-43c3-a29a-9591c6668f9c" class="">A single core computer can never run multiple programs at the same time. What it does is that it gives a little bit of time to every program being executed creating an illusion of multitasking. For example, if we run two different programs or multiple instances of the same program on a single core, it will run 1 instance/program for a few seconds/milliseconds and then switch to the other program being executed and give it resources for some time and so on. This is called multitasking, where the computer uses its context switching ability to switch back and forth between multiple programs. This will definitely increase program execution time as multiple programs are sharing the same CPU resources and time.</p><figure id="c1db6615-e10d-4eba-9cf6-3ac51e160dd8" class="image"><a href="https://miro.medium.com/v2/resize:fit:300/1*ZLLxUUq4C5T3n3VwNd2AEg.png"><img style="width:300px" src="https://miro.medium.com/v2/resize:fit:300/1*ZLLxUUq4C5T3n3VwNd2AEg.png"/></a></figure><p id="da1b2a1d-9cb9-45ee-b7ca-7f6aae486671" class="">geeksforgeeks.com</p><p id="bec550f4-764b-47db-aab6-d86b4d243859" class=""><em><strong>What if a program being executed has multiple threads?</strong></em></p><p id="621bacd7-580c-4710-abcd-00575fc31f53" class="">A <strong>thread</strong> is the smallest piece of instructions from a large program. If a single program/process needs to do multiple tasks concurrently, it divides these tasks into threads. For instance, an application has to download the data and update the progress bar as well, it can download data in one thread and update UI in the other. Some important properties of threads are:</p><ul id="64d4599b-e93c-43ac-8abd-d747d526032c" class="bulleted-list"><li style="list-style-type:disc">sub-tasks of the main program</li></ul><ul id="505cd13e-9323-4c69-bc0f-5a9dbf564c75" class="bulleted-list"><li style="list-style-type:disc">Share CPU resources with each other</li></ul><ul id="16b004b6-714a-415a-a1d9-dea8fbcd32d4" class="bulleted-list"><li style="list-style-type:disc">can be paused, stopped, and resumed</li></ul><p id="497bec74-f23e-4ada-8959-7231cb08e130" class="">This way of executing multiple threads/tasks of a single process/program is called <strong>Multithreading.</strong></p><figure id="09863a19-cbef-4b73-bf7d-8e34db1389d7" class="image"><a href="https://miro.medium.com/v2/resize:fit:700/1*o6gwyGaV6KuwLMnsY6W9_Q.png"><img style="width:700px" src="https://miro.medium.com/v2/resize:fit:700/1*o6gwyGaV6KuwLMnsY6W9_Q.png"/></a></figure><blockquote id="47f7fa0f-4d9d-4358-aa97-31a4c50a437d" class="">Multithreading is a kind of multitasking where multiple tasks being executed are part of same program.</blockquote><p id="31366bd4-9ea3-4719-92bf-df1e7277afbd" class="">Now let’s assume we have a dual-core computer and we try to run a single non-threaded program, the CPU will execute that program in a single core and provide all its resources while the other core will sit free. When we try to run multiple non-threaded programs on a multi-core CPU, the computer will again utilize its multitasking ability and give each program, resources from its cores. A single program will run completely on 1 core while the other on the second and so on. CPU will give some time to each individual program being executed on its all cores. This is called <strong>Multiprocessing.</strong></p><blockquote id="d4cd03a0-1032-434d-bf6e-8dc1b49a00ab" class="">Multiple non-threaded programs share CPU cores but they will always complete their execution on a core where an execution was first started.</blockquote><p id="63299011-afa3-43a3-a562-39d5378b5e00" class="">When we try to run the multi-threaded program on a multi-core CPU, the CPU will utilize its cores and run threads on all available cores. This is multi-threading on a multi-core CPU and this is also called<strong> Multiprocessing.</strong></p><figure id="db12d946-e5f8-41a3-b127-f794130a74db" class="image"><a href="https://miro.medium.com/v2/resize:fit:544/1*UuYxB7xJXKU_g5F3l90fcw.png"><img style="width:544px" src="https://miro.medium.com/v2/resize:fit:544/1*UuYxB7xJXKU_g5F3l90fcw.png"/></a></figure><p id="e87788a4-1fdc-4a7a-95aa-6719135d1105" class="">To conclude, multithreading and multiprocessing utilize the computer’s multitasking ability which in turn use <strong>context switching</strong>.</p><ul id="a20931ba-4976-460a-80a9-155212b7c408" class="bulleted-list"><li style="list-style-type:disc">In multitasking, multiple programs and threads share the same CPU core.</li></ul><ul id="9a82c8c5-b3d6-48b9-89cd-8e9994f5cb8d" class="bulleted-list"><li style="list-style-type:disc">In multithreading, different threads of the same program share the same CPU core and execute concurrently.</li></ul><ul id="d6f12acd-9216-408c-8184-e15d241afc44" class="bulleted-list"><li style="list-style-type:disc">In multiprocessing, multiple programs and even multiple threads of the same program utilize all CPU cores available and this is the truest form of <strong>parallel processing </strong>where the CPU executes multiple programs or threads in parallel on its different cores.</li></ul></div></details><ul id="edbbb862-df51-4cca-84f7-1744dbb11a01" class="toggle"><li><details open=""><summary>multi tasking vs multi threading</summary><table id="02f8b8c3-b4ae-4230-b331-9fa76ff26da5" class="simple-table"><tbody><tr id="448d1f83-5263-4128-bf60-5e741c330cac"><td id="sPrn" class="">Aspect</td><td id="gsH_" class="">Multithreading</td><td id="ekEa" class="">Multitasking</td></tr><tr id="5ed59e24-cfb0-45a8-ba24-b72bad79f823"><td id="sPrn" class="">Definition</td><td id="gsH_" class="">Multiple threads of execution within a single process</td><td id="ekEa" class="">Multiple processes running concurrently</td></tr><tr id="4a304956-ba18-4057-b291-3a1f938c8324"><td id="sPrn" class="">Resource Sharing</td><td id="gsH_" class="">Threads share the same memory space and resources of the parent process</td><td id="ekEa" class="">Each process has its own memory space and resources</td></tr><tr id="d226caee-1eb6-48b0-94db-8080c8e259d0"><td id="sPrn" class="">Communication</td><td id="gsH_" class="">Inter-thread communication is relatively easy and fast</td><td id="ekEa" class="">Inter-process communication is more complex and slower</td></tr><tr id="bbb6203d-e81d-4936-afa3-edc8e03091e6"><td id="sPrn" class="">Context Switching</td><td id="gsH_" class="">Faster and less resource-intensive</td><td id="ekEa" class="">Slower and more resource-intensive</td></tr><tr id="626f05b1-9b71-436f-971a-1abc49a4a8d4"><td id="sPrn" class="">Overhead</td><td id="gsH_" class="">Lower overhead for creation and management</td><td id="ekEa" class="">Higher overhead for creation and management</td></tr><tr id="2232d8e2-e907-4c8e-9af5-d040f640a187"><td id="sPrn" class="">Stability</td><td id="gsH_" class="">If one thread crashes, it may affect the entire process</td><td id="ekEa" class="">If one process crashes, it generally doesn&#x27;t affect other processes</td></tr><tr id="aad08332-f871-4a58-8e90-76f78d8a7a88"><td id="sPrn" class="">Scalability</td><td id="gsH_" class="">Better for fine-grained, closely related tasks</td><td id="ekEa" class="">Better for independent, loosely coupled tasks</td></tr><tr id="55c3ee9f-f1cd-4528-982d-6cf72b2d860f"><td id="sPrn" class="">Parallelism</td><td id="gsH_" class="">Can achieve parallelism on multi-core systems, but limited by the number of cores</td><td id="ekEa" class="">Can achieve full parallelism across multiple cores or processors</td></tr><tr id="d5f39919-1503-411a-b147-451f067393d5"><td id="sPrn" class="">Programming Complexity</td><td id="gsH_" class="">Generally more complex to program and debug</td><td id="ekEa" class="">Simpler programming model, but may be less efficient for closely related tasks</td></tr><tr id="cb704b93-86b3-4405-927a-36a527c3b9ff"><td id="sPrn" class="">Use Cases</td><td id="gsH_" class="">Responsive user interfaces, parallel algorithms within an application</td><td id="ekEa" class="">Running multiple independent applications simultaneously</td></tr><tr id="d96a1665-3c19-4bce-92b8-c040785dd731"><td id="sPrn" class="">OS Support</td><td id="gsH_" class="">Supported by most modern operating systems</td><td id="ekEa" class="">Fundamental feature of all modern operating systems</td></tr><tr id="155be947-0dec-495e-b7d2-01d8d589a04d"><td id="sPrn" class="">Memory Usage</td><td id="gsH_" class="">More memory efficient as resources are shared</td><td id="ekEa" class="">Each process requires its own memory allocation</td></tr></tbody></table></details></li></ul><ul id="beeb03cc-0aa9-4f21-9b33-d7b8d102087e" class="toggle"><li><details open=""><summary><strong>How Operating System Boots up?</strong></summary><figure id="b3962e3d-f6f7-4786-a67d-2c44f7f3744c" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Untitled.png"><img style="width:556px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Untitled.png"/></a></figure><ol type="1" id="f5b47eb1-07f9-4b83-a229-e3156a1aee40" class="numbered-list" start="1"><li>Power on</li></ol><ol type="1" id="b2b4f006-5448-4059-908e-2e44d2c29d37" class="numbered-list" start="2"><li>Cpu loads BIOS or UEFI</li></ol><ol type="1" id="c5cf500a-5e15-4d2b-841e-a36b1a09cb25" class="numbered-list" start="3"><li>BIOS or UEFI run tests and init  hardware<ol type="a" id="d706537a-f72c-4d6b-be7b-e5bc32ce0bec" class="numbered-list" start="1"><li>loads some settings from a memory area backed by a CMOS battery. Without it the cpu starts beeping</li></ol><ol type="a" id="adc9aa38-a8a4-4703-9721-4b1b834f4534" class="numbered-list" start="2"><li>Actual BIOS program loads with settings</li></ol><ol type="a" id="29cde532-2443-4bf1-a5bc-238a141e17b5" class="numbered-list" start="3"><li><strong> POST (Power On Self Test) </strong>runs</li></ol></li></ol><ol type="1" id="f563b580-bf4f-4d35-9f5a-1ae809ca153a" class="numbered-list" start="4"><li>BIOS or UEFI hands off to boot device<ol type="a" id="96acba6d-5693-4041-80e3-9599f99ffa68" class="numbered-list" start="1"><li>Boot device is the device where the os boot related instructions are actually written, known as boot loader. The actual program to on the os. Like ssd, hdd, cd, usb device,etc</li></ol><ol type="a" id="b2061919-6dcc-44b5-9d0a-92a9591ebf4f" class="numbered-list" start="2"><li>Boot loader is the program when executed actually on the os</li></ol><p id="aa958ceb-56f5-4afa-a5ee-d0b5fd409947" class="">Boot loader exists in</p><ul id="12c9c781-170c-4f1c-8aa6-10d2fa16d810" class="bulleted-list"><li style="list-style-type:disc">MBR(Master boot record). It is used by BIOS. MBRs are located on partitioned hard drives, but not within a partition. Instead, it is stored separately on the first and master sector of a hard disk. Used by old system</li></ul><ul id="8cd2a283-9cd8-4ce2-ac60-20d686e58420" class="bulleted-list"><li style="list-style-type:disc">EFI (Extensible Firmware Interface) →Used by UEFI. Here a separate parition is present called EFI where boot loader is present</li></ul></li></ol><ol type="1" id="b8acebe5-7a7a-4c23-9435-553758fe7f7a" class="numbered-list" start="5"><li>Boot loader loads full os. <p id="b4177c12-7680-4cf6-a0f6-5a4a3f544c46" class="">Windows → bootmg.ext</p><p id="eba00e8e-ea60-43e4-9ab4-1053a8aa0691" class="">max → boot.efi</p><p id="ea8e8ec5-a18d-4861-acee-99bc8ad4534e" class="">linux → GRUB</p></li></ol><p id="196020ab-1951-4e2a-931d-9b92a97446c8" class="">
</p><p id="f2304177-b38f-4e72-b51b-e21dcc0415d8" class="">
</p></details></li></ul><ul id="c8ac4154-b79a-4b0d-9023-2110cf4e4f19" class="toggle"><li><details open=""><summary>32 bit vs 64 bit system</summary><p id="d6cf94e6-3528-463b-8db0-86df6c83c9ea" class="">Basically it is 32 bit per cycle</p><p id="af57cfea-70cf-4297-8974-94565437d7c6" class="">and 64 bit cycle</p><p id="5b5a4416-1c69-4fc9-bd2b-4f3fc1efe47a" class="">32 bits mean 2^32 RAM addresses it can access in one cycle</p><p id="1dc0246d-1e15-40f7-9891-66cf6efd82de" class="">That means at one cycle it can access 4gb of ram. If a 32 bit system has more gb of ram it will be of not much use as it can’t access more than 4gb in one cycle. It will need two cycles</p><table id="47b9d8e4-482b-4913-ba30-37f4b2ee946a" class="simple-table"><tbody><tr id="a4aa8dc1-6e48-4329-8f51-ca136edf7a3d"><td id="&gt;oh{" class=""><strong>Feature</strong></td><td id="lLHq" class=""><strong>32-Bit System</strong></td><td id="BYUi" class=""><strong>64-Bit System</strong></td></tr><tr id="2714ff22-f3f1-400c-811a-33719e64eeba"><td id="&gt;oh{" class=""><strong>Data Processing Capability</strong></td><td id="lLHq" class="">Can process 32 bits of data per clock cycle.</td><td id="BYUi" class="">Can process 64 bits of data per clock cycle.</td></tr><tr id="ce188974-8ad9-4e28-8e1d-bb3b3511f681"><td id="&gt;oh{" class=""><strong>RAM Support</strong></td><td id="lLHq" class="">Can address up to 4GB of RAM.</td><td id="BYUi" class="">Can theoretically address up to 16 exabytes of RAM, commonly up to 128GB or more in consumer systems.</td></tr><tr id="fa8383db-fff3-4f1b-9378-e363cf364e57"><td id="&gt;oh{" class=""><strong>Performance</strong></td><td id="lLHq" class="">Generally slower for demanding applications.</td><td id="BYUi" class="">Faster for memory-intensive and computational tasks due to wider data paths.</td></tr><tr id="e7b36767-09ad-4673-b707-a723f51f52fa"><td id="&gt;oh{" class=""><strong>Operating System Support</strong></td><td id="lLHq" class="">Only supports 32-bit operating systems.</td><td id="BYUi" class="">Can run both 32-bit and 64-bit operating systems.</td></tr><tr id="0bb332fd-9381-44f9-9ee1-0cda77ea320c"><td id="&gt;oh{" class=""><strong>Software Compatibility</strong></td><td id="lLHq" class="">Limited to 32-bit software.</td><td id="BYUi" class="">Can run both 32-bit and 64-bit software.</td></tr><tr id="5211991d-218f-4f7a-83be-f35daaf7922a"><td id="&gt;oh{" class=""><strong>Application Performance</strong></td><td id="lLHq" class="">Less efficient in handling large datasets or complex calculations.</td><td id="BYUi" class="">More efficient, especially for applications like video editing, 3D rendering, and gaming.</td></tr><tr id="85275bd6-f0d9-4ee1-a84a-0fc7079449b5"><td id="&gt;oh{" class=""><strong>Security Features</strong></td><td id="lLHq" class="">Fewer security features, lacks support for certain hardware-based security enhancements like DEP (Data Execution Prevention) and ASLR (Address Space Layout Randomization) at full capacity.</td><td id="BYUi" class="">Enhanced security features, supports DEP, ASLR, and other modern security protocols more effectively.</td></tr><tr id="f061c4d0-a443-4edd-a6ec-f90dbe8e4fc4"><td id="&gt;oh{" class=""><strong>Virtualization</strong></td><td id="lLHq" class="">Limited virtualization capabilities.</td><td id="BYUi" class="">Better support for virtualization, allowing for more robust virtual machines.</td></tr><tr id="12f9d160-ea35-4cbb-b912-39ba281855bc"><td id="&gt;oh{" class=""><strong>Cost</strong></td><td id="lLHq" class="">Typically found in older, less expensive systems.</td><td id="BYUi" class="">More modern and can be more expensive due to better performance and capabilities.</td></tr><tr id="758f6fb7-0124-42c4-84dd-883ab60426c8"><td id="&gt;oh{" class=""><strong>Energy Consumption</strong></td><td id="lLHq" class="">Generally consumes less power but provides lower performance.</td><td id="BYUi" class="">May consume more power but offers significantly better performance.</td></tr><tr id="435b1362-2fdb-4702-aed5-9bc2be61aafb"><td id="&gt;oh{" class=""><strong>Use Case</strong></td><td id="lLHq" class="">Suitable for basic tasks like web browsing, office applications, and light media consumption.</td><td id="BYUi" class="">Suitable for more demanding tasks like gaming, video editing, 3D modeling, and heavy multitasking.</td></tr></tbody></table><h3 id="dd91bcfe-b2f7-4c15-ad14-265763608a23" class="">How 32 bit cpu will perform operation more than this?</h3><p id="dc1f39c4-26a3-4f27-b175-356b5883d22d" class="">Ex - adding two 64 bit integer where accross 64 bits (1/0) they are stored in the ram</p><ul id="aeb29c13-5fb7-414b-9e84-aa967112837f" class="bulleted-list"><li style="list-style-type:disc"><strong>Split the 64-bit Integer</strong>: The 64-bit integer is split into two 32-bit halves (the lower 32 bits and the upper 32 bits).<ul id="2ffe506f-1716-4628-a91c-7253a2c64fa6" class="bulleted-list"><li style="list-style-type:circle">For example, a 64-bit integer might be represented as two 32-bit values: <code>low</code> (lower 32 bits) and <code>high</code> (upper 32 bits).</li></ul></li></ul><ul id="5bb66d42-5eb9-4f16-b386-298402b47038" class="bulleted-list"><li style="list-style-type:disc"><strong>Perform Addition Separately</strong>:<ul id="cc70d54a-e511-41bb-8192-1e12d36347d7" class="bulleted-list"><li style="list-style-type:circle"><strong>Add the Lower 32 Bits</strong>: The CPU first adds the lower 32 bits of the two integers.</li></ul><ul id="7a95b041-16c3-43c2-bc1c-0cec87fc4559" class="bulleted-list"><li style="list-style-type:circle"><strong>Carry Over</strong>: If there&#x27;s a carry-out from the addition of the lower 32 bits (i.e., the result exceeds 32 bits), this carry is added to the addition of the upper 32 bits.</li></ul><ul id="7e800112-4c35-47b9-bb2b-fd0b8ec09138" class="bulleted-list"><li style="list-style-type:circle"><strong>Add the Upper 32 Bits</strong>: The CPU then adds the upper 32 bits, including any carry from the lower 32-bit addition.</li></ul></li></ul><ul id="e0499462-88bf-4926-9062-ecbfd4cb6266" class="bulleted-list"><li style="list-style-type:disc"><strong>Combine the Results</strong>: The results from the two separate 32-bit additions are combined to form the final 64-bit result.</li></ul></details></li></ul><hr id="3753cd83-297e-4857-8ac6-7677921a4c99"/><h3 id="d3cd0497-0eb7-414a-9adc-6e187fc26937" class="">Program and Process and Threads</h3><ul id="76755baf-9615-492b-86e0-f44b9b126c4e" class="toggle"><li><details open=""><summary>program , process, threads</summary><h3 id="ac8aad73-1ea1-491e-909b-fe8ea5b21530" class="">Program</h3><p id="ddc0aaf4-4a6c-4ef0-8a6e-76c410e70e6e" class="">Program is a set of instructions stored on disk</p><hr id="1c08f2cb-6bef-44f6-85bd-f79ba122c50b"/><h3 id="ec1a0218-81d3-4be1-a494-ee8f2e401543" class="">Process</h3><ul id="569c7ee8-97d4-454b-976f-324c99da83d5" class="toggle"><li><details open=""><summary>Formal definitions</summary><p id="9158e75b-e5fa-4df0-a8d0-507c8689d82d" class="">&quot;A process is an independent, actively executing instance of a program, with its own memory space, system resources, and execution state, managed by the operating system.&quot;</p><p id="432b64db-cfac-4c19-8b4f-3c0d4d3a8340" class="">Key points to consider:</p><ol type="1" id="f21200c1-6809-4531-bd4d-1fe150e84bea" class="numbered-list" start="1"><li>Independence: Each process runs independently of others, with its own memory space.</li></ol><ol type="1" id="5322d04b-dced-4696-8750-89244bdb643d" class="numbered-list" start="2"><li>Active execution: It&#x27;s not just code, but code being actively executed.</li></ol><ol type="1" id="a77e94f9-2cf7-4e84-abff-42926c909295" class="numbered-list" start="3"><li>Resource ownership: It has its own allocated resources.</li></ol><ol type="1" id="c81397ba-efb6-4157-b58f-4e8ca628e9ba" class="numbered-list" start="4"><li>Managed by OS: The operating system creates, schedules, and terminates processes.</li></ol></details></li></ul><p id="76e33b6e-98ac-428e-aba9-a2af525b9ed6" class="">When a program is loaded into memory and executed by processor , it becomes a process</p><p id="677406be-c593-4752-a71c-2e382f70a7bf" class="">An active process also includes the resources a program needs to run → I/O, ram, cpu and these resources are managed by the os.</p><p id="67c9e14e-0afb-417c-9145-84cbfc02ba3e" class="">Each process have their own memory address. Physical memory address space is shared, processes typically have their own virtual address spaces for isolation and protection. </p><p id="1fa6f115-10e0-43c3-8bfc-0b2feab1308a" class="">This means if one process malfunctions it does not affect other processes. Ex- In chrome , we open tabs which are processes. So if one tab is creating issue it does not affect other tabs</p><ul id="229e31a9-218e-4d4f-9c25-dd356e8ab3bc" class="toggle"><li><details open=""><summary>Things shared between separate process</summary><p id="6ab26d65-7f1f-4095-973a-363d859ba0c5" class="">In a multiprocessor system, multiple processes typically share several key resources:</p><ol type="1" id="603fa4f3-78c4-4e70-b1e3-108081694a62" class="numbered-list" start="1"><li>Memory:<ul id="46cb6685-649f-4bd7-ac53-2c2aaacb4ffd" class="bulleted-list"><li style="list-style-type:disc">Main memory (RAM) is often shared among processes.</li></ul><ul id="ac7f2162-2419-4fbc-92a7-569b001ccf99" class="bulleted-list"><li style="list-style-type:disc">This allows for efficient communication and data sharing between processes.</li></ul></li></ol><ol type="1" id="1d924373-6677-4dea-9156-d08ea4f48fa8" class="numbered-list" start="2"><li>I/O devices:<ul id="46431108-3320-459f-8866-755de09037b4" class="bulleted-list"><li style="list-style-type:disc">Peripherals like disk drives, network interfaces, and printers are usually shared.</li></ul><ul id="15f53daf-de5f-48c0-9492-d3bc4823fa09" class="bulleted-list"><li style="list-style-type:disc">This enables efficient resource utilization across processes.</li></ul></li></ol><ol type="1" id="d152b230-8616-410e-8d70-34d1dfc10750" class="numbered-list" start="3"><li>Bus:<ul id="a5b02047-5d01-4ef6-9c4b-cda24dd14421" class="bulleted-list"><li style="list-style-type:disc">The system bus, which connects various components, is shared.</li></ul><ul id="3e0847f5-a369-493f-9391-b07f77e6d16a" class="bulleted-list"><li style="list-style-type:disc">It facilitates data transfer between processors, memory, and I/O devices.</li></ul></li></ol><ol type="1" id="7c18f3d4-2458-485d-a990-2621b76ef2d9" class="numbered-list" start="4"><li>Clock:<ul id="81d31b35-1452-40b1-8bd3-f4106088c894" class="bulleted-list"><li style="list-style-type:disc">A common system clock is typically shared to synchronize operations.</li></ul></li></ol><ol type="1" id="e9912d51-be09-476f-a076-cdf1a3013449" class="numbered-list" start="5"><li>Cache:<ul id="371fce8c-e602-45b5-8755-b594aa9c1b78" class="bulleted-list"><li style="list-style-type:disc">Depending on the architecture, some levels of cache (e.g., L3 cache) may be shared among processors.</li></ul></li></ol><ol type="1" id="bad2a7d3-5544-47b8-85ae-2b54c41de059" class="numbered-list" start="6"><li>Operating System services:<ul id="2b15913e-fef1-4625-8ce3-54f6b81a441b" class="bulleted-list"><li style="list-style-type:disc">Processes share OS services for resource management, scheduling, and system calls.</li></ul></li></ol><ol type="1" id="5682b731-e3df-457a-be25-59abdd2387f0" class="numbered-list" start="7"><li>File system:<ul id="32bcfc62-5391-419d-a60d-43f8fade05db" class="bulleted-list"><li style="list-style-type:disc">The file system is generally shared, allowing processes to access common files and directories.</li></ul></li></ol><ol type="1" id="398622c8-9146-4f6b-bd4e-36804b2a39aa" class="numbered-list" start="8"><li>Network resources:<ul id="57d1c6a6-2a5a-4255-ba7e-1eb7cecdc35f" class="bulleted-list"><li style="list-style-type:disc">In networked systems, processes share network resources and protocols.</li></ul></li></ol></details></li></ul><ul id="1fbbc0bc-4e61-4cae-98a9-900c2fba6c5c" class="toggle"><li><details open=""><summary>Things not getting shared</summary><ul id="acc8f079-e9a7-4b37-ae14-193bc498a4c6" class="bulleted-list"><li style="list-style-type:disc">Virtual Memory Address Space:<ul id="6e8e50f8-91c6-4130-9904-55a61a2093bc" class="bulleted-list"><li style="list-style-type:circle">Each process usually has its own virtual address space, which is not directly shared with other processes.</li></ul><ul id="fdbb2919-17a0-44ca-9268-7aba1c9ff6dd" class="bulleted-list"><li style="list-style-type:circle">The operating system and memory management unit (MMU) handle the translation between virtual and physical addresses.</li></ul></li></ul><ul id="fc36a89e-156a-4b60-90e3-a68e0a45b420" class="bulleted-list"><li style="list-style-type:disc">Shared Memory Segments:<ul id="7a994ace-1c01-4191-93b4-78556d54ba67" class="bulleted-list"><li style="list-style-type:circle">Processes can share specific memory segments if explicitly set up to do so.</li></ul><ul id="20ba6aa4-a9f6-4950-9f41-0901f515520e" class="bulleted-list"><li style="list-style-type:circle">This allows for inter-process communication and data sharing.</li></ul></li></ul><ul id="a20f6e34-0af7-43bb-b7a0-b526fc1d5c18" class="bulleted-list"><li style="list-style-type:disc">Memory Mapping:<ul id="e35c52d7-6303-4a62-a6f1-edc83842f065" class="bulleted-list"><li style="list-style-type:circle">While each process has its own virtual address space, multiple processes can map the same physical memory to different virtual addresses.</li></ul><ul id="df139acf-327d-44af-833e-82e3ac32f204" class="bulleted-list"><li style="list-style-type:circle">This is often used for shared libraries or shared memory communication.</li></ul></li></ul><ul id="b57e8760-aba5-4fd5-8c4e-bca0f8d6cc50" class="bulleted-list"><li style="list-style-type:disc">Cache Coherency:<ul id="74a4f8ed-d5fa-4cd1-9123-3909848d340d" class="bulleted-list"><li style="list-style-type:circle">In multiprocessor systems, maintaining consistent views of memory across different processor caches is crucial.</li></ul><ul id="688ad695-7475-464f-a62a-13ae66c47b55" class="bulleted-list"><li style="list-style-type:circle">Cache coherency protocols ensure that changes in one processor&#x27;s cache are properly reflected in others.</li></ul></li></ul><hr id="b141bf78-7d7a-4cfa-91ef-ff6e7b646d6f"/><p id="325d5c33-2513-4d7a-9da3-971da8c0393b" class="">So basically ,</p><ol type="1" id="ba69d4d9-61c9-4a6f-bc57-cc76ae2c7137" class="numbered-list" start="1"><li>Stack Memory:<ul id="18f39272-f535-461c-8d5b-b3c8e13da2f4" class="bulleted-list"><li style="list-style-type:disc">Not shared between processes</li></ul><ul id="b39fd620-2de7-4e2d-99bd-40ce0ef66765" class="bulleted-list"><li style="list-style-type:disc">Each process has its own stack</li></ul><ul id="8ca3fae2-1538-47f2-9141-c96ebad63a15" class="bulleted-list"><li style="list-style-type:disc">Used for local variables, function calls, and program execution context</li></ul><ul id="36b81f01-3363-46d2-a6bb-03b62dbcc0eb" class="bulleted-list"><li style="list-style-type:disc">Managed automatically by the program</li></ul></li></ol><ol type="1" id="7f69d4a3-d865-4830-a639-bbc98a66756f" class="numbered-list" start="2"><li>Heap Memory:<ul id="b179faf1-6536-495e-a69f-3bc8e9f4acb1" class="bulleted-list"><li style="list-style-type:disc">Generally not shared between processes by default</li></ul><ul id="e6e743f2-a82c-45ab-8ea3-824054360938" class="bulleted-list"><li style="list-style-type:disc">Each process typically has its own heap</li></ul><ul id="a9404ae3-7d39-4acd-b11c-3f3f0130dece" class="bulleted-list"><li style="list-style-type:disc">Used for dynamic memory allocation (e.g., using malloc in C or new in C++)</li></ul><ul id="8628708b-1909-4590-b9c0-0a633ddbd821" class="bulleted-list"><li style="list-style-type:disc">Managed by the programmer (allocation and deallocation)</li></ul></li></ol></details></li></ul><hr id="72e19aba-6dc1-48ca-8a91-782393813807"/><h3 id="47e33397-1567-4f44-b752-cfba912b56a3" class="">Thread</h3><p id="fb3d90f2-b70d-444e-8a3d-3a0e2ad54484" class="">A thread is the smallest unit of execution(work) within a process that can be independently executed inside a process. Ex - making network calls, listening to keystrokes,etc</p><ul id="9ad2cfb1-94f8-40f5-b292-23936cc2166b" class="bulleted-list"><li style="list-style-type:disc">A <em><strong>thread</strong></em> is a basic unit of CPU utilization, consisting of a program counter, a stack, and a set of registers, ( and a thread ID. )</li></ul><ul id="d2383369-f519-4856-9eb9-b57a1e0b3012" class="bulleted-list"><li style="list-style-type:disc">A malfunction thread can break the whole process</li></ul><p id="44d85d82-34d1-4e2b-bdb2-c62e483c4118" class="">It is also a lightweight process</p><p id="8b38c6fb-9548-432d-a847-a6d6033dbecd" class="">Every process have atleast one thread called main thread</p><ul id="8a1f5612-5136-4a67-a9ed-5a0e8de63b6d" class="toggle"><li><details open=""><summary>Formal Definition</summary><p id="96c46b7e-2bbd-438a-be4e-e8dc86b7ab87" class="">In a process, a thread refers to a single sequential activity being executed. these activities are also known as thread of execution or thread control. Now, any operating system process can execute a thread. we can say, that a process can have multiple threads.</p><p id="216f0a43-a878-461c-8473-7f7ac852d858" class="">Here Individual Thread Execution means</p><ul id="448f3c1e-85fc-4fe3-a4bd-81a9f6a11e2f" class="bulleted-list"><li style="list-style-type:disc">Each individual thread executes its own instructions sequentially.</li></ul><ul id="917f958c-8b35-4cf3-8aa4-f355f39d7171" class="bulleted-list"><li style="list-style-type:disc">Within a single thread, operations occur one after another in a linear fashion.</li></ul></details></li></ul><ul id="e2f0a61a-9e57-484f-b10d-b61e833ab0f6" class="toggle"><li><details open=""><summary>why do we need threads</summary><ol type="1" id="bfd2ea6a-d4df-40a9-bca3-ad1c8ab2a354" class="numbered-list" start="1"><li>Responsiveness - One thread may provide rapid response while other threads are blocked or slowed down doing intensive calculations.</li></ol><ol type="1" id="36576486-f69b-4758-ac90-9c070e02d043" class="numbered-list" start="2"><li>Resource sharing - By default threads share common code, data, and other resources, which allows multiple tasks to be performed simultaneously in a single address space.</li></ol><ol type="1" id="b79979ec-0c9f-4dff-8505-9260ec2597b8" class="numbered-list" start="3"><li>Economy - Creating and managing threads ( and context switches between them ) is much faster than performing the same tasks for processes.</li></ol><ol type="1" id="1c696717-fc70-4e1b-a00e-d1ecbf2e8a43" class="numbered-list" start="4"><li>Scalability, i.e. Utilization of multiprocessor architectures - A single threaded process can only run on one CPU, no matter how many may be available, whereas the execution of a multi-threaded application may be split amongst available processors. ( Note that single threaded processes can still benefit from multi-processor architectures when there are multiple processes contending for the CPU, i.e. when the load average is above some certain threshold. )</li></ol><hr id="7e113e51-18e9-4b74-aaba-e191756502f7"/><ul id="5f38e1d4-3948-4f4a-a5f1-1d017d9406b9" class="bulleted-list"><li style="list-style-type:disc">Threads are very useful in modern programming whenever a process has multiple tasks to perform independently of the others.</li></ul><ul id="340a5ddc-36ef-4092-815c-a7b46253b5e6" class="bulleted-list"><li style="list-style-type:disc">This is particularly true when one of the tasks may block, and it is desired to allow the other tasks to proceed without blocking.</li></ul><ul id="d612c559-946a-41de-a2bb-7c943f4efc91" class="bulleted-list"><li style="list-style-type:disc">For example in a word processor, a background thread may check spelling and grammar while a foreground thread processes user input ( keystrokes ), while yet a third thread loads images from the hard drive, and a fourth does periodic automatic backups of the file being edited.</li></ul><ul id="930cde5c-a16c-4d49-9c51-d298c3f50586" class="bulleted-list"><li style="list-style-type:disc">Another example is a web server - Multiple threads allow for multiple requests to be satisfied simultaneously, without having to service requests sequentially or to fork off separate processes for every incoming request. ( The latter is how this sort of thing was done before the concept of threads was developed. A daemon would listen at a port, fork off a child for every incoming request to be processed, and then go back to listening to the port. )</li></ul></details></li></ul><ul id="fa948e8c-d554-4129-bb40-b206661c96de" class="toggle"><li><details open=""><summary>what a does single consists of </summary><ul id="337c4f64-385f-4b1d-bc70-054becbce7c9" class="bulleted-list"><li style="list-style-type:disc">Program Counter (PC):<ul id="01237152-21e1-4a03-a741-021b1df05369" class="bulleted-list"><li style="list-style-type:circle">Keeps track of which instruction is currently being executed by the thread.</li></ul></li></ul><ul id="92010cf2-b408-4fb9-8591-b29b4623783b" class="bulleted-list"><li style="list-style-type:disc">Register Set:<ul id="58e5c820-1f73-4076-9cde-292e2104e41b" class="bulleted-list"><li style="list-style-type:circle">CPU registers containing thread-specific data.</li></ul></li></ul><ul id="d71c15e1-e6e5-402f-bcdd-9ff6e7a5f47e" class="bulleted-list"><li style="list-style-type:disc">Stack:<ul id="8e8e59b6-992d-4c90-9e2e-d62b90cb8815" class="bulleted-list"><li style="list-style-type:circle">Each thread has its own stack for local variables, function parameters, and return addresses.</li></ul></li></ul><ul id="61b59b51-f5f3-442e-bd9a-4153bbc1aac2" class="bulleted-list"><li style="list-style-type:disc">Thread ID:<ul id="c2e0a347-2cdb-44e9-9335-69bf5d8ddc1b" class="bulleted-list"><li style="list-style-type:circle">A unique identifier assigned by the system.</li></ul></li></ul><ul id="217ef786-f23b-4bb7-937b-3f8938df9ea1" class="bulleted-list"><li style="list-style-type:disc">Thread-specific data (TSD):<ul id="52ddae4d-d97c-4af3-acbe-f5be06a2b3f8" class="bulleted-list"><li style="list-style-type:circle">Data that is unique to each thread.</li></ul></li></ul><ul id="12d2f5db-1ef7-4835-9d28-c23eefaad49b" class="bulleted-list"><li style="list-style-type:disc">Thread state:<ul id="fba32ce2-938e-4360-a6bf-7db9e0ef0061" class="bulleted-list"><li style="list-style-type:circle">Such as running, ready, blocked, or terminated.</li></ul></li></ul><ul id="2354f267-7bdf-4ace-b697-a6a497715fab" class="bulleted-list"><li style="list-style-type:disc">Priority:<ul id="fe9365b7-4d24-4166-9610-e14f1dc34abe" class="bulleted-list"><li style="list-style-type:circle">Used by the scheduler to determine execution order.</li></ul></li></ul></details></li></ul><ul id="59cc223a-8828-4382-ae2f-9ca0f7cfd8f8" class="toggle"><li><details open=""><summary>Things shared between multiple threads in a single process</summary><figure id="a6a74250-7472-409e-a6e1-efa6ee28c07c" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Untitled%201.png"><img style="width:680px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Untitled%201.png"/></a></figure><p id="6fbff793-bef6-4b04-adff-6face6263116" class="">Multiple threads within the same process share:</p><ol type="1" id="935e76d7-6eef-4687-bb01-5d1559bce939" class="numbered-list" start="1"><li>Code section:<ul id="c76ec2f5-c165-47d4-9aa9-f461629989b8" class="bulleted-list"><li style="list-style-type:disc">The program instructions.</li></ul></li></ol><ol type="1" id="30046ade-f972-418a-bc24-1678e52e6162" class="numbered-list" start="2"><li>Data section:<ul id="a18a702c-2050-4114-8e14-b3ede5b656b8" class="bulleted-list"><li style="list-style-type:disc">Global and static variables.</li></ul></li></ol><ol type="1" id="d5927fe5-a02a-4189-8fbb-b8b296a97e5f" class="numbered-list" start="3"><li>Heap memory:<ul id="f90511a7-3d95-40c1-a14d-cbd05126c527" class="bulleted-list"><li style="list-style-type:disc">Dynamically allocated memory.</li></ul></li></ol><ol type="1" id="1850d043-7a7e-447f-bb84-52b332da44b2" class="numbered-list" start="4"><li>File descriptors:<ul id="f5e69713-44ce-4c22-9956-8db165613ebd" class="bulleted-list"><li style="list-style-type:disc">Open file handles and network sockets.</li></ul></li></ol><ol type="1" id="75eb55db-eba4-4d54-9c28-76176337cae2" class="numbered-list" start="5"><li>Signals and signal handlers:<ul id="9c6cea7e-6c27-4914-98c7-a04d684a70eb" class="bulleted-list"><li style="list-style-type:disc">Though each thread can block signals individually.</li></ul></li></ol><ol type="1" id="62a68f30-10dc-41de-a1f2-2527babbbc4a" class="numbered-list" start="6"><li>Process ID:<ul id="1357f55c-c42e-497a-920f-b781e525b4ec" class="bulleted-list"><li style="list-style-type:disc">All threads of a process share the same process identifier.</li></ul></li></ol><ol type="1" id="a7377d28-cb57-4842-9fdf-75860e1e0016" class="numbered-list" start="7"><li>Parent process ID:<ul id="9594d29e-78dd-4982-9367-4d487f7b6553" class="bulleted-list"><li style="list-style-type:disc">The ID of the parent process.</li></ul></li></ol><ol type="1" id="92d57580-a97e-40d5-b2f3-08fb3823b83e" class="numbered-list" start="8"><li>Process group ID and session ID:<ul id="c6caab4d-2d84-4f52-ac33-ceb777f598a3" class="bulleted-list"><li style="list-style-type:disc">Used for job control and sessions.</li></ul></li></ol><ol type="1" id="a044399e-bc57-4288-852d-f1674a31ef16" class="numbered-list" start="9"><li>Current working directory:<ul id="2961b87a-457a-4477-9623-f907a60f7936" class="bulleted-list"><li style="list-style-type:disc">Though threads can change this, it affects all threads.</li></ul></li></ol><ol type="1" id="781f1966-9d0e-4bdc-a4c7-178d3fa9e5b5" class="numbered-list" start="10"><li>User and group IDs:<ul id="bc3e9e8f-0a6a-49ca-a1e3-09686b33fc64" class="bulleted-list"><li style="list-style-type:disc">Process-wide permissions.</li></ul></li></ol><ol type="1" id="cd7a4b3d-d2bc-43ed-9dee-3e7d712b764b" class="numbered-list" start="11"><li>Memory maps:<ul id="1c453c29-2f65-4b3f-a273-37b1a0738deb" class="bulleted-list"><li style="list-style-type:disc">Shared libraries and mapped files.</li></ul></li></ol></details></li></ul><ul id="e0fd1fa9-92fb-4945-8b37-2c9087952447" class="toggle"><li><details open=""><summary>stack is not shared but heap is shared??</summary><p id="4757f99d-9366-49b7-ab80-aac5a28f0b44" class="">Why stack is not shared:</p><ol type="1" id="0e032263-5753-4796-8ed1-c4773803b8ea" class="numbered-list" start="1"><li>Function Execution:<ul id="7aa8d2f4-2eb2-476e-9500-2472eb0f3575" class="bulleted-list"><li style="list-style-type:disc">Each thread needs its own stack to manage function calls, local variables, and return addresses independently.</li></ul></li></ol><ol type="1" id="98f5bc8d-e6d2-4579-9feb-a8bade331c5a" class="numbered-list" start="2"><li>Thread Independence:<ul id="7711171f-5a9b-4b06-88d3-eb395b82b263" class="bulleted-list"><li style="list-style-type:disc">Separate stacks allow threads to execute different functions simultaneously without interfering with each other.</li></ul></li></ol><ol type="1" id="d183149a-12e6-47ab-bd3e-6b03373b570d" class="numbered-list" start="3"><li>Context Switching:<ul id="c87c6089-0288-424e-8727-44af5339c708" class="bulleted-list"><li style="list-style-type:disc">Having individual stacks makes it easier and faster for the OS to switch between threads, as each thread&#x27;s execution context is self-contained.</li></ul></li></ol><ol type="1" id="df45e7d6-a4f8-416b-8c14-d4529149152b" class="numbered-list" start="4"><li>Recursion:<ul id="63a85bf9-2654-4a91-b26a-968757c06569" class="bulleted-list"><li style="list-style-type:disc">Separate stacks allow each thread to handle recursive function calls independently.</li></ul></li></ol><ol type="1" id="e8faa08d-7cf7-4bd6-9822-c6d142e00474" class="numbered-list" start="5"><li>Thread Safety:<ul id="78330756-1ddd-4c6c-98aa-2a57f21a044d" class="bulleted-list"><li style="list-style-type:disc">Local variables on the stack are naturally thread-safe, reducing the need for synchronization for thread-local data.</li></ul></li></ol><p id="90ef7b7c-b3f9-4b81-8f23-e6729740a787" class="">Why heap is shared:</p><ol type="1" id="79e487b1-e390-48de-97ae-330943996e9c" class="numbered-list" start="1"><li>Data Sharing:<ul id="f9498f0a-eb07-4c16-a35f-c4651c8f2845" class="bulleted-list"><li style="list-style-type:disc">Allows threads to easily share data and communicate with each other through common data structures.</li></ul></li></ol><ol type="1" id="316d3eb5-b136-4c75-aa92-8eb90710d015" class="numbered-list" start="2"><li>Memory Efficiency:<ul id="71cd3bfe-c188-474d-a97a-c07a41afe945" class="bulleted-list"><li style="list-style-type:disc">Sharing the heap avoids the need to duplicate large data structures for each thread, saving memory.</li></ul></li></ol><ol type="1" id="bba01cee-408b-4860-9530-55322f58ea23" class="numbered-list" start="3"><li>Flexibility:<ul id="485bccb8-d7f3-44b1-8372-fbb25a3eefd1" class="bulleted-list"><li style="list-style-type:disc">Enables dynamic allocation of memory that can be accessed by any thread in the process.</li></ul></li></ol><ol type="1" id="19a5c598-d185-4832-9632-e259a31f222c" class="numbered-list" start="4"><li>Lifetime Management:<ul id="00f37a6d-f83a-4d61-b262-ed81318c9ed7" class="bulleted-list"><li style="list-style-type:disc">Objects on the heap can outlive the thread that created them, allowing for more complex programming patterns.</li></ul></li></ol><ol type="1" id="bb4df569-4801-4e49-9dd1-800019bd5e6d" class="numbered-list" start="5"><li>Global State:<ul id="228b0573-1626-4b22-a974-c6e4c24d18ad" class="bulleted-list"><li style="list-style-type:disc">Facilitates the implementation of global or shared state within the application.</li></ul></li></ol><ol type="1" id="6dd05f17-6a71-4770-a39a-8a2515920580" class="numbered-list" start="6"><li>Performance:<ul id="b210ab0a-17c9-4d8c-b009-4bea38268124" class="bulleted-list"><li style="list-style-type:disc">Allocating separate heaps for each thread would be resource-intensive and complicate memory management.</li></ul></li></ol></details></li></ul></details></li></ul><ul id="57f17f7d-cdb8-4434-ba18-b35974450b3c" class="toggle"><li><details open=""><summary>how many threads we should create to get the maximum benifit</summary><p id="59a4df11-0001-410f-8726-385d7bd03c0d" class="">The number of physical cores in your system is a crucial factor. In general, you want to match the number of compute-bound threads to the number of available cores.</p><p id="3a87399d-00c8-49ae-9b83-aab93321c7aa" class="">If you have dual core cpu, then two threads will run parallelly in two cpus and if more than two will run in parallely and other will get divided in the cores and concurrently they will start executing</p><p id="a74d8cf8-8b8f-48c5-b4dc-b10a71603a04" class="">When you have more threads than cores, the system will indeed use a combination of parallelism and concurrency. However, the behavior is a bit more nuanced:</p><ul id="b5447436-38eb-4cc0-bc8a-9af690cba065" class="bulleted-list"><li style="list-style-type:disc">At any given moment, two threads will still be running in parallel (one on each core).</li></ul><ul id="c96039d4-e4d2-46fc-beed-8a7564b4e20e" class="bulleted-list"><li style="list-style-type:disc">The operating system&#x27;s scheduler will rapidly switch between the other threads, creating concurrency.</li></ul><ul id="f963b521-edd8-4a11-b0bb-81d3a79a4488" class="bulleted-list"><li style="list-style-type:disc">This switching happens so quickly that it gives the illusion of all threads running simultaneously.</li></ul><p id="55500351-364f-4700-b945-65096fa2ae2f" class="">
</p></details></li></ul><ul id="7f22be43-67da-4564-995d-7361739dbd33" class="toggle"><li><details open=""><summary>Sequential vs Concurrency vs Parallelism</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="05742fb1-892c-4dc1-bba9-f12b4f4d59bf"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Parallelism is a subset of concurrency</div></figure><p id="664d6d6c-a59e-44eb-8d73-d4a3c506d966" class=""><a href="https://medium.com/@itIsMadhavan/concurrency-vs-parallelism-a-brief-review-b337c8dac350">https://medium.com/@itIsMadhavan/concurrency-vs-parallelism-a-brief-review-b337c8dac350</a></p><p id="350fe365-d433-4194-83f5-3458534276b3" class=""><a href="https://www.youtube.com/watch?v=r2__Rw8vu1M&amp;t=3s">https://www.youtube.com/watch?v=r2__Rw8vu1M&amp;t=3s</a></p><h3 id="ab59360c-fe9c-40d9-969f-29faf4f81c71" class="">Concurrency</h3><ul id="108f08da-2a2e-4ac9-8d54-572feca82e41" class="bulleted-list"><li style="list-style-type:disc"><em>Concurrency means executing multiple tasks at the same time but not necessarily simultaneously.</em></li></ul><ul id="9c700d15-b79f-4c92-adfd-ad7e8227032b" class="bulleted-list"><li style="list-style-type:disc">There are two tasks executing concurrently, but those are run in a 1-core CPU, so the CPU will decide to run a task first and then the other task or run half a task and half another task, etc. Two tasks can start, run, and complete in overlapping time periods i.e Task-2 can start even before Task-1 gets completed. It all depends on the system architecture.</li></ul><ul id="f79e761e-24ab-4521-87fe-bea79d976b9d" class="bulleted-list"><li style="list-style-type:disc">let&#x27;s take an example in real life: There’s a challenge that requires you to both eat a whole huge cake and sing a whole song. You’ll win if you’re the fastest who sings the whole song and finishes the cake. So the rule is that you sing and eat simultaneously, How you do that does not belong to the rule. You can eat the whole cake, then sing the whole song, or you can eat half a cake, then sing half a song, then do that again, etc.</li></ul><h3 id="0cfd8470-f9a2-4925-894c-f385ca93a35a" class="">Parallelism</h3><ul id="dfc3727c-045e-4893-9cce-6f4ddf253ce2" class="bulleted-list"><li style="list-style-type:disc">Parallelism means that an application splits its tasks up into smaller subtasks which can be processed in parallel, for instance on multiple CPUs at the exact same time.</li></ul><ul id="94921fc0-1d92-44d2-a02f-491f61147edd" class="bulleted-list"><li style="list-style-type:disc">Parallelism does not require two tasks to exist. It literally physically run parts of tasks OR multiple tasks, at the same time using the multi-core infrastructure of CPU, by assigning one core to each task or sub-task.</li></ul><ul id="7eec1181-4eb2-41f0-a0a8-4e36fd2ecc19" class="bulleted-list"><li style="list-style-type:disc">If we keep going with the same example as above, the rule is still singing and eating concurrently<strong>, </strong>but this time, you play in a team of two. You probably will eat and let your friend sing (because she sings better and you eat better). So this time, the two tasks are really executed simultaneously, and it’s called <em>parallel</em>.</li></ul><ul id="2edf636e-7668-4eee-ae41-da87b942f435" class="bulleted-list"><li style="list-style-type:disc">Parallelism requires hardware with multiple processing units, essentially. In single-core CPU, you may get concurrency but NOT parallelism. Parallelism is a specific kind of concurrency where tasks are really executed simultaneously.</li></ul><h3 id="55928fe3-a396-4758-9007-0cad3c354382" class="">Sequential</h3><p id="9ed027c5-de1a-45d0-9c9a-15e5e429ae11" class="">An application can be neither parallel — nor concurrent, which means that it processes all tasks one at a time, sequentially.</p><hr id="8ffc0b93-c2d6-432e-a589-ba34a914bdc6"/><blockquote id="fdd2edea-dd3d-4b89-9871-1c488c87fe78" class="">A system is said to be concurrent if it can support two or more actions in progress at the same time. A system is said to be parallel if it can support two or more actions executing simultaneously.</blockquote><p id="47e1fa34-44c0-49f1-8dc6-7267138d6018" class=""><em>The key concept and difference between these definitions is the phrase </em><strong>“in progress.”</strong></p><p id="4bdd1fe3-a31b-4306-ae94-c0792edd71d5" class="">This definition says that, in concurrent systems, multiple actions can be <em>in progress</em> (may not be executed) at the same time. Meanwhile, multiple actions are simultaneously executed in parallel systems. In fact, concurrency and parallelism are conceptually overlapped to some degree, but “in progress” clearly makes them different.</p><p id="5d415ef4-baba-4c0f-a878-48b3bda5a758" class="">Concurrency is about<strong> dealing with lots of things</strong> at once. Parallelism is about <strong>doing lots of things at once</strong>.</p><p id="15033567-67a1-4c86-b38f-6d92163e7893" class="">An application can be concurrent — but not parallel, which means that it processes more than one task at the same time, but no two tasks are executing at the same time instant.</p><p id="e24609ad-7a78-473d-a463-5c1d22eeb4e5" class="">An application can be parallel — but not concurrent, which means that it processes multiple sub-tasks of a task in multi-core CPU at the same time.</p><p id="9b0fa916-db68-4053-84ff-b5ccb16cda3b" class="">An application can be neither parallel — nor concurrent, which means that it processes all tasks one at a time, sequentially.</p><p id="888bc68e-cfcd-42ce-80a9-d2a20acfb2ce" class="">An application can be both parallel — and concurrent, which means that it processes multiple tasks concurrently in multi-core CPU at the same time.</p></details></li></ul><ul id="eb4971b0-fdc3-42db-8ca4-82336269cf20" class="toggle"><li><details open=""><summary>Process , threads along with parallelism and concurrency</summary><p id="9e5156cb-ba7b-4e5c-8857-c816eb9ed3b4" class="">Given:</p><ul id="c1ee92ea-44c0-46c7-b9c2-9d0f75e5f516" class="bulleted-list"><li style="list-style-type:disc">Dual-core CPU</li></ul><ul id="edc103ae-3989-4cfd-8e24-8b8ba11cd41d" class="bulleted-list"><li style="list-style-type:disc">Two processes running</li></ul><ul id="035e3452-7df9-4c35-a24d-c82bf8fae594" class="bulleted-list"><li style="list-style-type:disc">Each process has 3 threads</li></ul><p id="58eb6164-6398-4958-9f71-841bf18928c6" class="">In this scenario, we can have both parallelism and concurrency. Let&#x27;s examine how:</p><ol type="1" id="3a9acac2-2fb8-4fdb-bdf8-f2e585c05fd2" class="numbered-list" start="1"><li>Process-level parallelism:<br/>The two processes can run truly in parallel, with one process on each core. This is genuine parallelism at the process level.<br/></li></ol><ol type="1" id="03e45baf-f3a9-4beb-b52f-16fe4146b2da" class="numbered-list" start="2"><li>Thread-level parallelism and concurrency:<br/>Within each process, the three threads will exhibit a mix of parallelism and concurrency. Here&#x27;s why:<br/></li></ol><ul id="009f01f8-6089-4e8d-b072-bfc7be8e10ef" class="bulleted-list"><li style="list-style-type:disc">Parallelism: At any given moment, two threads (one from each process) can run truly in parallel on the two CPU cores.</li></ul><ul id="8b45d308-1742-4851-b5d9-e31ab600ceb1" class="bulleted-list"><li style="list-style-type:disc">Concurrency: Since there are more threads (6 total) than cores (2), not all threads can run simultaneously. The remaining threads will be scheduled concurrently, switching rapidly to give the illusion of parallelism.</li></ul><hr id="dc780a76-d843-40a2-8aaa-da48e6b70f85"/><h3 id="e1fd632e-4b24-44f0-9f3f-ba0618a1d2cd" class="">How parallel computing works in this scenario:</h3><ul id="5216c23b-1148-406b-b7c5-48f037ffc577" class="bulleted-list"><li style="list-style-type:disc">The operating system&#x27;s scheduler will allocate the two CPU cores to threads from the two processes.</li></ul><ul id="db90753d-4730-4cc6-8df3-de279311e6f6" class="bulleted-list"><li style="list-style-type:disc">At any given time, two threads will be executing in parallel, one on each core.</li></ul><ul id="8432a00e-d699-4a23-8bc9-8f8cb6789c9f" class="bulleted-list"><li style="list-style-type:disc">The scheduler will switch between threads, giving each thread some execution time on the cores.</li></ul><ul id="2aa4e5f4-ee48-41a1-a42c-5c7e1fdf7e9c" class="bulleted-list"><li style="list-style-type:disc">This switching happens very quickly, creating the appearance of all threads running simultaneously.</li></ul><h3 id="d5ba9157-8453-4189-b17e-5681279b347e" class="">Parallelism breakdown:</h3><ul id="8f668c82-d495-40db-a227-f29353fad55f" class="bulleted-list"><li style="list-style-type:disc">Processes: Fully parallel (2 processes on 2 cores)</li></ul><ul id="598cd6f6-e0dd-429d-a513-ffb820a5eedb" class="bulleted-list"><li style="list-style-type:disc">Threads: Partially parallel, partially concurrent (2 threads running in parallel at a time, others waiting/switching)</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="fa655fc3-b83a-4c44-bcd4-c6888954c90f" class="code"><code class="language-YAML">Core 1: [P1T1]----[P1T2]----[P1T3]----[P1T1]----
Core 2: [P2T1]----[P2T2]----[P2T3]----[P2T1]----</code></pre><h3 id="2f1ae68b-16f2-40ab-840f-0eebbee71452" class="">Key points:</h3><ol type="1" id="6d42005c-1941-470b-875a-20ee747adf16" class="numbered-list" start="1"><li>The two processes are always running in parallel.</li></ol><ol type="1" id="e1299431-037a-453e-8253-e1c16eb0dbf5" class="numbered-list" start="2"><li>At any instant, two threads (one from each process) are running in parallel.</li></ol><ol type="1" id="8c634d15-9396-40a0-94bf-b0ca30521d97" class="numbered-list" start="3"><li>The other four threads are in a waiting state, ready to be scheduled.</li></ol><ol type="1" id="3dac5743-28b1-480e-ac9a-040bbc00fbce" class="numbered-list" start="4"><li>The OS scheduler rapidly switches between threads, creating concurrency.</li></ol></details></li></ul><ul id="6e9aa238-fcca-4837-bc22-cbceba400d3b" class="toggle"><li><details open=""><summary>running multiple threads on multi processor vs running on single process os</summary><ul id="fab63fdd-a9c2-4619-b7d0-c3c9b6c4e860" class="bulleted-list"><li style="list-style-type:disc">One CPU core can only process <strong>one task at a time</strong>, but a CPU with multiple cores can process multiple tasks simultaneously. Threads can be thought of as subtasks of a larger recipe</li></ul><ul id="824c3b2c-7213-44a5-a50f-ab8467fa0971" class="bulleted-list"><li style="list-style-type:disc">In multi-processor system , multiple threads execute , <strong>simultaneously</strong> on different cores. Eg- If there are two threads and two cores , then each thread would run on individual core.</li></ul><ul id="3ae75f1f-e155-496c-a36d-daed6cb3cb52" class="bulleted-list"><li style="list-style-type:disc">In a single-processor system, multiple threads execute , one after the other or wait until one thread finishes or is preempted by the OS , depending on the thread priority and the OS policy.But the running threads , gives an illusion that they run simultaneous , relative to the required application response time of the User space application.</li></ul><p id="66914b6b-1efd-4e67-9dd6-b4a5d2f96c8f" class="">Time Comparison(Example):</p><p id="4b1a951a-53e5-4534-8d42-4ca6a651a8e5" class="">if two threads take 10us each to execute, then on a 2 processor system , the net time take is 10us</p><p id="190a04aa-0f14-40cf-9423-39cd11d84591" class="">if two threads take 10us each to execute, then on a 1 processor system , the net time take is 20us</p><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">4 core cpu handling 4 threads</summary><div class="indented"><ul id="6116a139-3035-439f-8867-b65116f186aa" class="bulleted-list"><li style="list-style-type:disc">The operating system assigns each thread to a separate core.</li></ul><ul id="1f25a15a-9570-49a8-9b0f-2441c08b326a" class="bulleted-list"><li style="list-style-type:disc">All threads start executing simultaneously on their assigned cores.</li></ul><ul id="720b6a42-bf2b-4ea7-9a4d-1868ed5655d7" class="bulleted-list"><li style="list-style-type:disc">Each thread runs continuously on its core until completion.</li></ul><ul id="64a5428a-d7fe-40d0-9751-56e89b9ee4eb" class="bulleted-list"><li style="list-style-type:disc">If a thread finishes early, the core can be reassigned to another thread if available.</li></ul><ul id="7b075929-1b68-439e-9cff-7dae5548c9a8" class="bulleted-list"><li style="list-style-type:disc">Synchronization between threads (if needed) is managed through various mechanisms like mutexes or semaphores.</li></ul><hr id="0dce81c5-2681-433b-aff2-8de3282a3b3a"/><ul id="26e93abf-a53f-4390-ad07-3d99514459fc" class="bulleted-list"><li style="list-style-type:disc">True parallelism is achieved as each thread runs on its own core.</li></ul><ul id="e81ad219-1b2c-439b-b417-634118dc0d13" class="bulleted-list"><li style="list-style-type:disc">The total execution time is roughly equal to the longest running thread.</li></ul><ul id="9bd65c18-8dce-4cd7-b64e-78e431d068b3" class="bulleted-list"><li style="list-style-type:disc">The OS handles load balancing and may redistribute threads if cores become available.</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4fa6b607-7c40-47cc-bbe7-52be7775a5ca" class="code"><code class="language-Mermaid">gantt
    title Multi-processor Workflow
    dateFormat X
    axisFormat %L
    section Core 1
    Thread A    :a1, 0, 4
    section Core 2
    Thread B    :b1, 0, 4
    section Core 3
    Thread C    :c1, 0, 4
    section Core 4
    Thread D    :d1, 0, 4</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">single core cpu handling 4 threads</summary><div class="indented"><ul id="c59824fe-9c1d-4fe9-9d50-3c9a485ceb03" class="bulleted-list"><li style="list-style-type:disc">The OS maintains a queue of threads ready to execute.</li></ul><ul id="c59c8816-108c-4c21-8023-95e7c14d364c" class="bulleted-list"><li style="list-style-type:disc">The processor executes one thread at a time for a small time slice (e.g., a few milliseconds).</li></ul><ul id="5059ee1a-ffc6-43ab-ab1d-825191655e05" class="bulleted-list"><li style="list-style-type:disc">When the time slice expires, the OS performs a context switch:<ul id="69523330-fe35-491f-820b-93f5342fd957" class="bulleted-list"><li style="list-style-type:circle">It saves the current thread&#x27;s state (registers, program counter, etc.).</li></ul><ul id="3e05fb47-6d48-4708-857c-afffc893c2f4" class="bulleted-list"><li style="list-style-type:circle">It loads the next thread&#x27;s state from the queue.</li></ul></li></ul><ul id="f5f62ca6-0422-441a-a808-506c7ed04c6a" class="bulleted-list"><li style="list-style-type:disc">This process repeats, cycling through all active threads.</li></ul><ul id="08aa5afc-c284-49b6-a267-03be2d5f8c39" class="bulleted-list"><li style="list-style-type:disc">If a thread is blocked (e.g., waiting for I/O), it&#x27;s moved to a waiting queue, and the next ready thread is executed.</li></ul><ul id="178a80e1-2484-42c3-801a-b0a79bcbf0e2" class="bulleted-list"><li style="list-style-type:disc">When a thread completes, it&#x27;s removed from the queue.</li></ul><hr id="56e11c16-f9ed-47d4-bf3c-e753bdd1686d"/><ul id="2ef69f79-2128-4371-a9a9-a374f35f8a49" class="bulleted-list"><li style="list-style-type:disc">Only one thread is actually executing at any given moment.</li></ul><ul id="7a570b88-c24e-4cc6-b2e1-db5d0ce38574" class="bulleted-list"><li style="list-style-type:disc">The rapid switching between threads creates an illusion of parallelism.</li></ul><ul id="a23f9378-896d-41c7-8528-a174820704e9" class="bulleted-list"><li style="list-style-type:disc">The total execution time is roughly the sum of all thread execution times, plus overhead from context switching.</li></ul><ul id="c6b52ccf-f3ba-483d-9d68-b6f9e43cf161" class="bulleted-list"><li style="list-style-type:disc">The frequency of context switches balances responsiveness with the overhead of switching.</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="319e1f8f-c64f-47f2-972b-0b53bfb0348c" class="code"><code class="language-Mermaid">gantt
    title Single-processor Workflow
    dateFormat X
    axisFormat %L
    section Processor
    Thread A    :a1, 0, 1
    Thread B    :b1, 1, 2
    Thread C    :c1, 2, 3
    Thread D    :d1, 3, 4
    Thread A    :a2, 4, 5
    Thread B    :b2, 5, 6
    Thread C    :c2, 6, 7
    Thread D    :d2, 7, 8</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">How 8 threads will be scheduled on 4 core cpu</summary><div class="indented"><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5de6a99a-9bec-4dde-b81a-6a6b4c6a7bfa" class="code"><code class="language-Mermaid">gantt
    title 8 Threads on 4 Cores
    dateFormat X
    axisFormat %L
    section Core 1
    Thread A    :a1, 0, 2
    Thread E    :e1, 2, 4
    Thread A    :a2, 4, 6
    Thread E    :e2, 6, 8
    section Core 2
    Thread B    :b1, 0, 2
    Thread F    :f1, 2, 4
    Thread B    :b2, 4, 6
    Thread F    :f2, 6, 8
    section Core 3
    Thread C    :c1, 0, 2
    Thread G    :g1, 2, 4
    Thread C    :c2, 4, 6
    Thread G    :g2, 6, 8
    section Core 4
    Thread D    :d1, 0, 2
    Thread H    :h1, 2, 4
    Thread D    :d2, 4, 6
    Thread H    :h2, 6, 8</code></pre><ol type="1" id="3a50e0fe-4fc7-416c-bc08-217d98603a6c" class="numbered-list" start="1"><li>Initial Assignment:<ul id="dc08606c-131a-4df8-bc22-421a53f5cdfa" class="bulleted-list"><li style="list-style-type:disc">The operating system initially assigns threads A, B, C, and D to the four cores.</li></ul><ul id="11b9c2c8-117d-4fe4-8ed6-3290bada20c4" class="bulleted-list"><li style="list-style-type:disc">Threads E, F, G, and H are placed in a ready queue.</li></ul></li></ol><ol type="1" id="51c052e2-6ca7-49aa-9916-2b4cd8013726" class="numbered-list" start="2"><li>Time-Slicing and Context Switching:<ul id="d755abe1-f731-485c-b7e4-6735585c78f4" class="bulleted-list"><li style="list-style-type:disc">Each core executes its assigned thread for a specific time slice (e.g., 2 time units in our diagram).</li></ul><ul id="76318eda-ae0e-4aa7-a711-50db8e3849e4" class="bulleted-list"><li style="list-style-type:disc">After the time slice expires, the OS performs a context switch on each core:<ul id="567abe15-7af6-460f-9d9e-661425d6649a" class="bulleted-list"><li style="list-style-type:circle">It saves the state of the currently running thread (A, B, C, or D).</li></ul><ul id="b2a49bcc-42f3-454b-98db-56834d27f28d" class="bulleted-list"><li style="list-style-type:circle">It loads the state of a waiting thread (E, F, G, or H) onto the core.</li></ul></li></ul></li></ol><ol type="1" id="a4b99e13-035c-4b35-91dc-9dad2d1edab1" class="numbered-list" start="3"><li>Continuous Rotation:<ul id="138742f2-333f-402c-bbc7-70850ae9ded3" class="bulleted-list"><li style="list-style-type:disc">This process continues, with threads being swapped in and out of the cores.</li></ul><ul id="31395522-a717-4f16-a337-f4bdb72534fc" class="bulleted-list"><li style="list-style-type:disc">In our diagram, after threads E, F, G, and H run, the system switches back to A, B, C, and D.</li></ul></li></ol><ol type="1" id="44a4d581-e947-4569-a573-c30aaafaa6dc" class="numbered-list" start="4"><li>Dynamic Scheduling:<ul id="bd3b1095-301b-406c-9ce1-89b9eede4309" class="bulleted-list"><li style="list-style-type:disc">The OS uses sophisticated scheduling algorithms to determine which threads run next.</li></ul><ul id="6706cf43-5a76-48fb-b9d5-a32a96fc3c34" class="bulleted-list"><li style="list-style-type:disc">Factors considered include thread priority, how long a thread has been waiting, and its recent CPU usage.</li></ul></li></ol><ol type="1" id="93276052-2d6c-44e5-95b4-d1d287b17d0e" class="numbered-list" start="5"><li>Load Balancing:<ul id="0e397d38-3e2b-44f2-a7a3-1d2f2a9acb8d" class="bulleted-list"><li style="list-style-type:disc">The OS tries to distribute the threads evenly across all cores to maximize CPU utilization.</li></ul><ul id="f4a8b3ee-6cc7-4064-a6b0-623d935a9a48" class="bulleted-list"><li style="list-style-type:disc">If one thread finishes early, the OS may redistribute the remaining threads.</li></ul></li></ol><ol type="1" id="a30c4405-0093-405a-9d28-f48c350e5c84" class="numbered-list" start="6"><li>Handling I/O and Blocking:<ul id="dea3c7fd-c41c-402d-a46f-41d683705bdb" class="bulleted-list"><li style="list-style-type:disc">If a thread becomes blocked (e.g., waiting for I/O), the OS immediately switches it out for a ready thread.</li></ul><ul id="1dfb246a-0da7-4cbf-8b3e-8b5c734b44e2" class="bulleted-list"><li style="list-style-type:disc">This ensures that cores aren&#x27;t idle while waiting for blocked threads.</li></ul></li></ol><p id="3c28360a-561e-4167-9649-5ebe2c270efa" class="">Key Points:</p><ul id="3e9295b6-0acf-4d61-9271-d936b50d1200" class="bulleted-list"><li style="list-style-type:disc">True parallelism: Four threads are always running in parallel on the four cores.</li></ul><ul id="ff2a9223-1be9-49e0-a385-f84a73ad8bd4" class="bulleted-list"><li style="list-style-type:disc">Concurrency: All eight threads make progress over time, even though only four run simultaneously.</li></ul><ul id="d4a2d6bc-661f-4d21-a7d2-6b543f5ecf4b" class="bulleted-list"><li style="list-style-type:disc">Context switching overhead: There&#x27;s some performance cost to frequently switching between threads.</li></ul><ul id="db833b35-ba17-49d6-ae6c-6e74e64ec367" class="bulleted-list"><li style="list-style-type:disc">Responsiveness: Time-slicing ensures all threads get regular CPU time, maintaining system responsiveness.</li></ul><ul id="8790418c-a7ea-4499-9cf3-bb50bbd60db0" class="bulleted-list"><li style="list-style-type:disc">Efficient CPU utilization: The system aims to keep all cores busy, maximizing overall throughput.</li></ul><p id="b6f8a2b4-6b8f-4331-bc59-9ec99fcaeb18" class="">This approach allows the system to handle more threads than it has physical cores, providing an illusion of all threads running simultaneously. The rapid switching between threads is typically fast enough that, for many applications, the performance is similar to having eight slow cores instead of four fast ones.</p></div></details></details></li></ul><ul id="5f6673e1-9d72-442c-8a34-5eb64a3f0485" class="toggle"><li><details open=""><summary><strong>Is the execution of a program equal to only one process or multiple processes sometimes?</strong></summary><p id="4bfac7a5-98f3-4218-9593-d7f1363b580d" class="">Here the name of the program is Chrome and teams. And the number showing the number of processes are running</p><figure id="1a3c7405-442a-4719-84d8-9aea1ab3a455" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Untitled%202.png"><img style="width:602px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Untitled%202.png"/></a></figure><p id="abce5579-c3f8-4a83-8e51-7b30f1b90e9d" class="">The execution of a program can involve either one process or multiple processes, depending on how the program is designed and executed. Let me explain:</p><ol type="1" id="97a86175-3405-48f5-8e57-ec1241afb885" class="numbered-list" start="1"><li>Single-process execution:<br/>Many programs run as a single process. When you launch a simple application, the operating system creates one process to execute that program&#x27;s instructions.<br/></li></ol><ol type="1" id="0e88cfe1-7b7a-4335-a23a-eaa0d4f67cad" class="numbered-list" start="2"><li>Multi-process execution:<br/>Some programs can spawn multiple processes during execution. This can happen in several scenarios:<br/>a) Intentional design: The program might be designed to create child processes for parallel processing or to separate different functionalities.<br/>b) Forking: In Unix-like systems, a process can create an exact copy of itself using the fork() system call.<br/>c) Background services: Some applications might launch separate processes for background tasks or services.<br/>d) Multi-processing frameworks: Languages like Python have libraries (e.g., multiprocessing) that allow programs to spawn multiple processes for parallel execution.<br/></li></ol><ol type="1" id="97a8d316-4b69-4700-8035-14fb78923909" class="numbered-list" start="3"><li>Related concepts:<ul id="16f78530-26af-491c-9274-b7675db5edac" class="bulleted-list"><li style="list-style-type:disc">Threads: A single process can have multiple threads of execution, which are lighter-weight than full processes and share the same memory space.</li></ul><ul id="d8b39c79-49b5-4ed8-9a89-1e537f02bcd8" class="bulleted-list"><li style="list-style-type:disc">Distributed systems: Some large-scale applications might run across multiple machines, involving numerous processes working together.</li></ul></li></ol><p id="8a76035d-afc5-429c-845a-fdafe97852ed" class="">In summary, while many programs run as a single process, it&#x27;s quite common for more complex applications to involve multiple processes during execution. The choice often depends on the program&#x27;s requirements, design, and the specific problem it&#x27;s solving.</p></details></li></ul><ul id="c3d41905-ff15-4090-af8c-93e83442f801" class="toggle"><li><details open=""><summary>process vs threads</summary><p id="2190ab0d-b0b2-42df-9031-b657b82c852f" class=""><a href="https://www.namehero.com/blog/cpu-cores-vs-threads-everything-you-need-to-know/">https://www.namehero.com/blog/cpu-cores-vs-threads-everything-you-need-to-know/</a></p><table id="27b0de79-2019-4597-98ab-cc6056babab0" class="simple-table"><tbody><tr id="4d7eae34-dc7e-45f5-b33d-debe24855f1b"><td id="FCld" class="">Aspect</td><td id="Y&lt;&gt;T" class="">Threads</td><td id="XC|@" class="">Processes</td></tr><tr id="4ffb2ba5-3cbe-47cd-9105-90dbbba7708c"><td id="FCld" class="">Definition</td><td id="Y&lt;&gt;T" class="">Lightweight unit of execution within a process</td><td id="XC|@" class="">Independent program in execution</td></tr><tr id="d9cf75dc-aae7-4676-94e5-bd382f99b440"><td id="FCld" class="">Creation</td><td id="Y&lt;&gt;T" class="">Faster and less resource-intensive</td><td id="XC|@" class="">Slower and more resource-intensive</td></tr><tr id="4b30ae3e-40db-4ee5-8270-7578c15d13c4"><td id="FCld" class="">Memory Space</td><td id="Y&lt;&gt;T" class="">Share memory space of the parent process</td><td id="XC|@" class="">Have their own separate memory space</td></tr><tr id="337a1b38-7529-466d-9458-9f987246cdb6"><td id="FCld" class="">Communication</td><td id="Y&lt;&gt;T" class="">Easy and fast (shared memory)</td><td id="XC|@" class="">More complex (IPC mechanisms required)</td></tr><tr id="2c5d0b68-62c2-4851-ba52-cb8b719255ef"><td id="FCld" class="">Context Switching</td><td id="Y&lt;&gt;T" class="">Faster</td><td id="XC|@" class="">Slower</td></tr><tr id="936a60ab-a990-4a85-a7b4-2ae6ac785a8a"><td id="FCld" class="">Resource Ownership</td><td id="Y&lt;&gt;T" class="">Share resources of the parent process</td><td id="XC|@" class="">Own and control their resources</td></tr><tr id="2d6106f7-c265-4823-9ea1-dfe05057c50b"><td id="FCld" class="">Dependency</td><td id="Y&lt;&gt;T" class="">Dependent on the parent process</td><td id="XC|@" class="">Independent entities</td></tr><tr id="6eb1cda4-53fe-45ac-97d4-a4ea88dbf39f"><td id="FCld" class="">Termination</td><td id="Y&lt;&gt;T" class="">Terminating a thread may not end the process</td><td id="XC|@" class="">Terminating a process ends all its threads</td></tr><tr id="40b88e95-e558-48e5-9659-969b0c80d3d9"><td id="FCld" class="">Data Sharing</td><td id="Y&lt;&gt;T" class="">Can directly access shared data</td><td id="XC|@" class="">Need explicit mechanisms to share data</td></tr><tr id="22db05ce-9671-465c-8c51-8248d9620cb6"><td id="FCld" class="">Security/Stability</td><td id="Y&lt;&gt;T" class="">Issue in one thread can affect the whole process</td><td id="XC|@" class="">More isolated; issues don&#x27;t directly affect others</td></tr><tr id="e7ff96a6-3b23-4b13-82fe-28a52615434a"><td id="FCld" class="">Unique Elements</td><td id="Y&lt;&gt;T" class="">Thread ID, stack, registers, program counter</td><td id="XC|@" class="">Process ID, memory space, file descriptors</td></tr><tr id="1f52ced2-265d-442e-995c-2ed294677de7"><td id="FCld" class="">Shared Elements</td><td id="Y&lt;&gt;T" class="">Code section, data section, open files, signals</td><td id="XC|@" class="">None (unless explicitly set up)</td></tr><tr id="4d31cff3-43b4-4cf9-8ae8-fb0745cec125"><td id="FCld" class="">Overhead</td><td id="Y&lt;&gt;T" class="">Low</td><td id="XC|@" class="">Higher</td></tr><tr id="124be799-d796-43fe-af65-99980dc48ef5"><td id="FCld" class="">Scalability</td><td id="Y&lt;&gt;T" class="">Better for small-scale parallelism</td><td id="XC|@" class="">Better for large-scale parallelism</td></tr><tr id="ce2e97fa-bc78-4e07-9c8f-3ccf65583cea"><td id="FCld" class="">Programming Complexity</td><td id="Y&lt;&gt;T" class="">Can be more complex due to synchronization needs</td><td id="XC|@" class="">Generally simpler to manage</td></tr><tr id="9f62420f-fc2b-4a38-8f69-744bf2186b14"><td id="FCld" class="">Use Case</td><td id="Y&lt;&gt;T" class="">Concurrent operations within an application</td><td id="XC|@" class="">Running separate applications</td></tr></tbody></table></details></li></ul><ul id="6770a171-e6c2-44ce-82bb-412b937235fb" class="toggle"><li><details open=""><summary>does threads in a single process executes sequentially??</summary><p id="c8e3f646-93ff-4306-8126-d8568af68312" class="">No. </p></details></li></ul><ul id="7d21ad59-5f5d-4d93-b5bd-c13f571d2f1c" class="toggle"><li><details open=""><summary>switching threads is cheaper than switching processes</summary><p id="4987e0ea-840c-472f-913f-5e8fc242903d" class="">Thread switching is cheaper primarily because threads share resources within a process, requiring less state to be saved and restored during a switch. This makes thread switching a more lightweight operation, allowing for more efficient multitasking, especially in scenarios where quick context switches are frequent.</p><p id="8ae555df-be9d-450f-bbb3-74e7ed5f375b" class="">
</p><ol type="1" id="1f423fc4-fb83-427d-a710-a11dfd533c8e" class="numbered-list" start="1"><li>Memory Context:<br/>Threads:<br/><ul id="38ede814-0365-4e70-a893-dd239d21f63f" class="bulleted-list"><li style="list-style-type:disc">All threads within a process share the same memory space.</li></ul><ul id="1be98987-3e82-4d86-ab69-e9f00e12fe1c" class="bulleted-list"><li style="list-style-type:disc">When switching between threads, the memory context largely remains the same.</li></ul><p id="5fa6db7e-1b63-42a3-aa22-16851ca727e2" class="">Processes:</p><ul id="2ec38067-3cb3-43da-8c5d-bf66a6cb0d89" class="bulleted-list"><li style="list-style-type:disc">Each process has its own separate memory space.</li></ul><ul id="9441add8-6b27-4b7a-9cd6-24c7a8b4d50b" class="bulleted-list"><li style="list-style-type:disc">Switching processes requires a complete change of memory context.</li></ul></li></ol><ol type="1" id="d868432a-38f0-40b0-9a2c-4853279d4efb" class="numbered-list" start="2"><li>Resource Allocation:<br/>Threads:<br/><br/>Processes:<br/><ul id="02fa8042-ee80-4511-b016-c75749c0b21e" class="bulleted-list"><li style="list-style-type:disc">Share resources like file handles, network connections within the process.</li></ul><ul id="822562be-e673-489c-906c-f55e5f59cccf" class="bulleted-list"><li style="list-style-type:disc">Minimal resource reallocation needed during a switch.</li></ul><ul id="073e6ffd-79a7-4f37-bf47-340137ff4bdc" class="bulleted-list"><li style="list-style-type:disc">Have their own set of resources.</li></ul><ul id="94687e21-4977-4c7f-8059-3bb04ec0ebc9" class="bulleted-list"><li style="list-style-type:disc">Switching may involve saving and loading various system resources.</li></ul></li></ol><ol type="1" id="28dc9cd3-5235-4b49-807f-d85393613672" class="numbered-list" start="3"><li>CPU Context:<br/>Threads:<br/><br/>Processes:<br/><ul id="2a5b696e-19eb-46b9-9609-aee52ef19082" class="bulleted-list"><li style="list-style-type:disc">Share the same CPU context within a process.</li></ul><ul id="c59bc425-bd37-4a10-9706-24179bdcf928" class="bulleted-list"><li style="list-style-type:disc">Only thread-specific registers and stack pointer need to be saved/restored.</li></ul><ul id="ce5e9d1f-794e-44fc-b27e-1182dec6214e" class="bulleted-list"><li style="list-style-type:disc">Have separate CPU contexts.</li></ul><ul id="d84919a8-a985-4f46-95f4-2b3bad900784" class="bulleted-list"><li style="list-style-type:disc">Entire CPU state (all registers, memory management info, etc.) must be saved/restored.</li></ul></li></ol><ol type="1" id="e1e1cd57-8d47-4ee3-9468-260aa0f9b136" class="numbered-list" start="4"><li>Cache Impact:<br/>Threads:<br/><br/>Processes:<br/><ul id="59f6091a-e81e-4561-9251-31e667fbd1ee" class="bulleted-list"><li style="list-style-type:disc">Often benefit from shared cache data within the process.</li></ul><ul id="5819d1ca-ad06-4e30-ae8a-666eba460081" class="bulleted-list"><li style="list-style-type:disc">Less likely to cause significant cache misses during a switch.</li></ul><ul id="d308cb5f-6c98-4b44-b465-d63e827c888d" class="bulleted-list"><li style="list-style-type:disc">Switching usually invalidates a large portion of the CPU cache.</li></ul><ul id="9e06c3ba-4366-4f9e-abe2-8fffd428d05e" class="bulleted-list"><li style="list-style-type:disc">More frequent cache misses, leading to performance penalties.</li></ul></li></ol><ol type="1" id="22d01d9e-7189-483d-ac30-c93ddd3f0376" class="numbered-list" start="5"><li>Time Taken:<br/>Threads:<br/><br/>Processes:<br/><ul id="53710441-5e1a-485a-9638-bdc3439fccfe" class="bulleted-list"><li style="list-style-type:disc">Thread context switch typically takes microseconds.</li></ul><ul id="fe88544f-149b-4e19-be79-a03f7de7a047" class="bulleted-list"><li style="list-style-type:disc">Process context switch can take milliseconds (orders of magnitude longer).</li></ul></li></ol><ol type="1" id="2d7291de-ed34-4ab9-b28b-43dee0633557" class="numbered-list" start="6"><li>Kernel Involvement:<br/>Threads:<br/><br/>Processes:<br/><ul id="f001c9ff-046f-4883-ada7-7b4757cf251c" class="bulleted-list"><li style="list-style-type:disc">User-level threads can be switched without kernel intervention in some implementations.</li></ul><ul id="957801ff-63bb-4839-ba7e-48d939731593" class="bulleted-list"><li style="list-style-type:disc">Even for kernel-level threads, the operation is relatively lightweight.</li></ul><ul id="e01980a1-f4f6-452a-977b-03b4805d71b5" class="bulleted-list"><li style="list-style-type:disc">Always require kernel intervention for switching.</li></ul><ul id="441c3061-f6e1-42a1-a371-fb8d2c2bf137" class="bulleted-list"><li style="list-style-type:disc">Involves more complex operations at the kernel level.</li></ul></li></ol><ol type="1" id="767d0c07-bd1b-43e8-8a5a-f1bfd7fe91b8" class="numbered-list" start="7"><li>Data Sharing:<br/>Threads:<br/><br/>Processes:<br/><ul id="bec39bc4-fabe-4467-9749-ef5a5ac1c59a" class="bulleted-list"><li style="list-style-type:disc">Can directly access shared data within the process.</li></ul><ul id="d0523ce1-6bde-4f53-824a-60c2c4072205" class="bulleted-list"><li style="list-style-type:disc">No need for complex inter-process communication mechanisms.</li></ul><ul id="fcc79ec4-a074-475f-8c3d-5ba25018ad6a" class="bulleted-list"><li style="list-style-type:disc">Require mechanisms like pipes, shared memory, or message passing for data sharing.</li></ul><ul id="f054f921-4619-402e-88aa-52f988be8093" class="bulleted-list"><li style="list-style-type:disc">These mechanisms add overhead during context switches.</li></ul></li></ol><ol type="1" id="b9f1e4e8-ceda-4a0b-aee5-732adede2362" class="numbered-list" start="8"><li>Creation and Destruction:<br/>Threads:<br/><br/>Processes:<br/><ul id="900549b8-b2fe-433b-8d39-f28035bcbbc2" class="bulleted-list"><li style="list-style-type:disc">Faster and cheaper to create and destroy.</li></ul><ul id="729d02d6-7b03-4f43-8019-8300c00ab4ed" class="bulleted-list"><li style="list-style-type:disc">Often use thread pools to reuse thread contexts.</li></ul><ul id="273f05bb-ebbd-46e3-b693-2ad178b49818" class="bulleted-list"><li style="list-style-type:disc">More expensive to create and destroy.</li></ul><ul id="56e0ffd0-01d5-4ead-b5b7-451b209913b5" class="bulleted-list"><li style="list-style-type:disc">Each creation involves setting up a new, isolated environment.</li></ul></li></ol></details></li></ul><hr id="d45eb95a-8850-4056-bf3c-0b17b417aa04"/><hr id="42ee4b76-b301-4ddb-a15c-939769abf8f8"/><h3 id="310fcb67-b0d7-4a8a-b137-f6e2320bfe87" class="">Components of OS</h3><figure id="277f2222-4809-4f44-9e98-c909f565151d" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Untitled%203.png"><img style="width:595px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Untitled%203.png"/></a></figure><ul id="2d81abbd-abc4-4d6f-965a-85f5a498d738" class="toggle"><li><details open=""><summary>userspace</summary><p id="eb65b7ab-98bc-4ec0-a66b-468c2e20fe01" class="">Userspace is the environment where user-facing applications run. This includes applications such as web servers, Chrome, text editors, and command utilities. Userspace applications are also known as userland applications.</p><p id="9f032e3b-8bb0-4c2b-9b49-582dc716307e" class="">Userspace applications cannot directly access the system’s hardware resources. They must make system calls to the kernel to request access to these resources.</p></details></li></ul><ul id="1325e6f9-6112-4570-8cf7-209c399fe91b" class="toggle"><li><details open=""><summary>kernel</summary><p id="14808a40-d785-4ea1-aed9-7cfa7c6944fe" class="">Kernel is the part of the os which interacts with hardware and acts as a bridge between application and hardware</p><p id="1dc34753-64bc-4182-8c9a-5efb4116347a" class="">The kernel manages system resources, such as the CPU, memory, and devices, ensuring everything works together smoothly and efficiently. It handles tasks like running programs, accessing files, and connecting to devices like printers and keyboards.</p></details></li></ul><ul id="c98262ee-02da-4cea-8b61-8e3313bf24fe" class="toggle"><li><details open=""><summary>a separation between userspace and kernel</summary><p id="ff3f6474-8a60-42cf-bcc3-ae0c792a5137" class="">The separation of userspace and kernel space is a fundamental design principle in operating systems. This separation provides a number of benefits, including:</p><ul id="6f0ba299-f351-4db2-92ea-02d2949139cc" class="bulleted-list"><li style="list-style-type:disc"><strong>Security:</strong> It prevents userspace applications from accidentally or maliciously corrupting the kernel or other system resources.</li></ul><ul id="b1c73012-71ea-4902-972a-e6f993bed81e" class="bulleted-list"><li style="list-style-type:disc"><strong>Stability:</strong> It makes the operating system more stable by isolating the kernel from potential failures in userspace applications.</li></ul><ul id="413e880b-cb32-4daa-8be1-3dd259bb4351" class="bulleted-list"><li style="list-style-type:disc"><strong>Performance:</strong> It can improve the performance of the operating system by allowing the kernel to run in a protected environment.</li></ul><h3 id="4c1ff873-4303-42e5-ae3a-ed0a7dcf0d48" class="">Example</h3><p id="aa4d9823-e280-4c68-8e82-f8fa590c50a2" class="">Let’s take a real-world example of a simple Linux <code>ls</code> command. When you run the <code>ls</code> command to list files, the following happens:</p><ol type="1" id="4e8327da-1012-4c8c-8920-9fb67790a3d0" class="numbered-list" start="1"><li>The <code>ls</code> command is executed in userspace.</li></ol><ol type="1" id="6f207dd7-d5b1-40c4-83dd-8a124420ae23" class="numbered-list" start="2"><li>The <code>ls</code> command makes a system call (<code>getdents()</code>) to the kernel, asking it to list the files in the current directory.</li></ol><ol type="1" id="3168e32e-83a2-40ed-a458-59e55dc0af56" class="numbered-list" start="3"><li>The kernel receives the system call and performs the requested operation.</li></ol><ol type="1" id="eaf1e54e-72a8-4b54-892d-5b55d5e124ac" class="numbered-list" start="4"><li>The kernel returns the results of the operation to the <code>ls</code> command.</li></ol><ol type="1" id="45b726a0-de1c-4415-bba4-4dd75d035b27" class="numbered-list" start="5"><li>The <code>ls</code> command displays the results to the user.</li></ol><p id="f48a70d1-678d-4611-bc2c-a5adf0861bfc" class="">In this example, </p><p id="3a18984e-fe70-4b7a-a82d-603c55cf1016" class="">userspace application → the <code>ls</code> command that needs to access the system&#x27;s files. </p><p id="9dc356ec-a20a-4ed9-a793-bb7ed21d09e7" class="">kernel interaction → the <code>ls</code> command makes a system call to the kernel. The kernel then performs the requested operation and returns the results to the <code>ls</code> command.</p></details></li></ul><ul id="bbd5e62e-0e00-444d-8d46-5e4d26080480" class="toggle"><li><details open=""><summary>functions of kernel</summary><p id="25b76a85-430d-4877-a25b-7e4802ab9663" class="">1. <strong>Process management:</strong><br/>    ◦ Scheduling processes and threads on the CPUs.<br/>    ◦ Creating &amp; deleting both user and system process.<br/>    ◦ Suspending and resuming processes<br/>    ◦ Providing mechanisms for process synchronization or process communication.<br/>2. <br/><strong>Memory management:</strong><br/>    ◦ Allocating and deallocating memory space as per need.<br/>    ◦ Keeping track of which part of memory are currently being used and by which process.<br/>3. <br/><strong>File management:</strong><br/>    ◦ Creating and deleting files.<br/>    ◦ Creating and deleting directories to organize files.<br/>    ◦ Mapping files into secondary storage.<br/>    ◦ Backup support onto a stable storage media.<br/>4. <br/><strong>I/O management:</strong> to manage and control I/O operations and I/O devices<br/>    ◦ Buffering (data copy between two devices), caching and spooling.<br/>        ▪ Spooling<br/>            • Within differing speed two jobs.<br/>            • Eg. Print spooling and mail spooling.<br/>        ▪ Buffering<br/>            • Within one job.<br/>            • Eg. Youtube video buffering<br/>        ▪ Caching<br/>            • Memory caching, Web caching etc.<br/></p></details></li></ul><ul id="eca41da9-251d-4c5f-8e80-fdffeefe5d71" class="toggle"><li><details open=""><summary>how kernel works</summary><ul id="d9a074a8-30e0-43a0-ad63-7fa02ba9950d" class="bulleted-list"><li style="list-style-type:disc">A kernel loads first into memory when an operating system is loaded and remains in memory until the operating system is shut down again. It is responsible for various tasks such as <strong><a href="https://www.geeksforgeeks.org/disk-management-in-operating-system/">disk management</a></strong>, task management, and <strong><a href="https://www.geeksforgeeks.org/memory-management-in-operating-system/">memory management</a></strong>.</li></ul><ul id="81298eb7-d48d-455e-90ce-e774a5597a8c" class="bulleted-list"><li style="list-style-type:disc">The kernel has a process table that keeps track of all active processes</li></ul><ul id="8774781d-5608-4bfd-8105-64549a35802a" class="bulleted-list"><li style="list-style-type:disc">The process table contains a per-process region table whose entry points to entries in the region table.</li></ul><ul id="4785b803-6ac4-4f92-b050-112704bc0b73" class="bulleted-list"><li style="list-style-type:disc">The kernel loads an executable file into memory during the ‘exec’ system call’.</li></ul><ul id="5ca9c46a-74ff-467f-9381-6f1baa188133" class="bulleted-list"><li style="list-style-type:disc">It decides which process should be allocated to the processor to execute and which process should be kept in the main memory to execute. It basically acts as an interface between user applications and hardware. The major aim of the kernel is to manage communication between software i.e. user-level applications and hardware i.e., CPU and disk memory</li></ul></details></li></ul><ul id="ea1c2049-872a-4ff9-b213-b1b8c6cd736e" class="toggle"><li><details open=""><summary>software interrupt → for switching between kernel mode and user mode</summary><p id="a43a7944-3ca0-43f4-957e-d98879d6638e" class="">A software interrupt is a mechanism used in computer systems to temporarily pause the normal execution of a program and transfer control to a specific interrupt handler routine. Unlike hardware interrupts which are triggered by external devices, software interrupts are generated by software through specific instructions or exceptional conditions within the program.</p><ul id="a33a5ab4-ad02-497c-aa08-004c3a387903" class="bulleted-list"><li style="list-style-type:disc">Purpose:<ul id="39e6dd83-3fd8-496f-82bc-4258eade238b" class="bulleted-list"><li style="list-style-type:circle">To request services from the operating system</li></ul><ul id="e7b0fcf8-63c5-4fe9-8aba-0a457f812996" class="bulleted-list"><li style="list-style-type:circle">To switch between user mode and kernel mode</li></ul><ul id="714cde99-a69a-4c6a-8b42-676e35814b32" class="bulleted-list"><li style="list-style-type:circle">To handle exceptional conditions or errors in the program</li></ul></li></ul><ul id="be49043c-cebe-4934-8b1e-d1d73e810363" class="bulleted-list"><li style="list-style-type:disc">Mechanism:<ul id="a1a65ee3-e266-4f8a-80c9-78eb56a87ad2" class="bulleted-list"><li style="list-style-type:circle">Typically triggered by executing a special instruction (e.g., INT in x86 assembly)</li></ul><ul id="af2ce55f-5f71-4b10-84a6-ea5390511818" class="bulleted-list"><li style="list-style-type:circle">Can also be triggered by exceptional conditions like division by zero or accessing invalid memory</li></ul></li></ul><ul id="547f3305-5843-4cc4-bbb8-b912e9dbedcc" class="bulleted-list"><li style="list-style-type:disc">Handling:<ul id="dbf3832e-ffa2-41c7-a06d-98c199e60213" class="bulleted-list"><li style="list-style-type:circle">When a software interrupt occurs, the CPU saves the current state</li></ul><ul id="c9ae89b2-02d1-4875-b5c7-ae5c6ed63024" class="bulleted-list"><li style="list-style-type:circle">Control is transferred to a predefined interrupt handler in the operating system</li></ul><ul id="5e7d5ab8-104b-4c68-ba25-9c81c16f59ac" class="bulleted-list"><li style="list-style-type:circle">After handling, control returns to the original program</li></ul></li></ul><ul id="1d70d042-04b4-42f4-8435-b39a22b4b3d1" class="bulleted-list"><li style="list-style-type:disc">Examples of usage:<ul id="aa048036-441e-4c2d-a9c1-a1552d2679c4" class="bulleted-list"><li style="list-style-type:circle">System calls: Applications use software interrupts to request services from the OS</li></ul><ul id="b4f2fd28-20c2-47fd-828a-787a13c97c38" class="bulleted-list"><li style="list-style-type:circle">Exception handling: Used to manage runtime errors or exceptional conditions</li></ul><ul id="85042f0b-3f7f-48dc-ae35-0c5137bf5e0b" class="bulleted-list"><li style="list-style-type:circle">Debuggers: Can use software interrupts to implement breakpoints</li></ul></li></ul><ul id="3200109c-940c-4c03-bc71-bf28d2b6f4c0" class="bulleted-list"><li style="list-style-type:disc">Advantages:<ul id="d2117878-6b09-4f96-b936-d6fcda68f753" class="bulleted-list"><li style="list-style-type:circle">Provides a controlled way for user programs to access kernel services</li></ul><ul id="9122de27-5fba-4aa8-9d44-5ffb225798cb" class="bulleted-list"><li style="list-style-type:circle">Allows for centralized handling of common operations and errors</li></ul><ul id="b7a28641-6bb1-4b7e-998d-1c3fa132256f" class="bulleted-list"><li style="list-style-type:circle">Enhances system security by mediating access to privileged operations</li></ul></li></ul><ul id="b6919e68-1070-458a-a3a6-106e462fab3d" class="bulleted-list"><li style="list-style-type:disc">Implementation:<ul id="3c3cf3e8-b2c5-4b13-ba09-d8c36a21302c" class="bulleted-list"><li style="list-style-type:circle">In modern systems, software interrupts are often implemented using more efficient mechanisms like the SYSCALL instruction on x86-64 architectures</li></ul></li></ul><p id="8994e049-70f1-434d-be8e-f7276fd6b0d6" class="">
</p></details></li></ul><ul id="cd8854bd-ff7e-4e7b-a10d-d791343de14f" class="toggle"><li><details open=""><summary>Example usage of software interrupt</summary><p id="7a520458-746a-4b71-8897-6c1140a94daf" class="">In the implementation of a simple text editor. This example will illustrate how software interrupts facilitate interaction between a user application and the operating system.</p><p id="1e1af36b-3093-422f-b71e-fa18af44ae5b" class="">As you type, save your work, and eventually close the program, software interrupts are being used behind the scenes. Here&#x27;s how:</p><ol type="1" id="6bfdd340-2841-4c05-b9a3-e9319257e69a" class="numbered-list" start="1"><li>Keyboard Input:<br/>When you press a key, the following occurs:<br/><ul id="00e38a76-6b91-4bdf-be3d-7078c5e13fe1" class="bulleted-list"><li style="list-style-type:disc">The keyboard generates a hardware interrupt.</li></ul><ul id="20d73070-0a10-486c-880d-1c0aa84a94af" class="bulleted-list"><li style="list-style-type:disc">The OS keyboard driver handles this interrupt and places the character in a buffer.</li></ul><ul id="eec990f0-7320-4a61-bf24-fcfabac429c5" class="bulleted-list"><li style="list-style-type:disc">Your text editor application requests this input using a system call, which is implemented via a software interrupt.</li></ul><p id="88cf2bf8-6225-48be-b172-211063cb1a20" class="">Pseudocode</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3292e351-92b2-48f2-8750-40db4c98c519" class="code"><code class="language-YAML">char = system_call(READ_KEYBOARD)</code></pre><ol type="1" id="455a5220-f712-4f91-9331-b67e6115ff14" class="numbered-list" start="2"><li>Displaying Text:<br/>As you type, the editor needs to display the characters on the screen:<br/><ul id="8476990f-5b32-4fca-acb3-39c732887ac9" class="bulleted-list"><li style="list-style-type:disc">The editor uses a system call to write to the display.</li></ul><ul id="9dd3accf-008e-4dfe-9cac-101bf3477321" class="bulleted-list"><li style="list-style-type:disc">This system call is again implemented using a software interrupt.</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="adb7fe2b-5125-41cb-a5b6-1179b5e4b91e" class="code"><code class="language-YAML">system_call(WRITE_DISPLAY, char, x_position, y_position)</code></pre></li></ol><p id="1d28cf98-a0ae-475b-b605-6b1cc56a4865" class="">same for saving</p></li></ol></details></li></ul><ul id="726198ba-98e1-4b3e-bbb9-a28ecc014277" class="toggle"><li><details open=""><summary>types of kernel</summary><ul id="0d12f338-7071-4791-8778-04c7b944476c" class="toggle"><li><details open=""><summary>monolithic</summary><p id="2a1a882d-0954-469f-b044-8cb1a5207e9d" class="">a. All functions are in kernel itself.<br/>b. Bulky in size.<br/>c. Memory required to run is high.<br/>d. Less reliable, one module crashes -&gt; whole kernel is down.<br/>e. High performance as communication is fast. (Less user mode, kernel<br/>mode overheads)<br/>f. Eg. Linux, Unix, MS-DOS.<br/></p></details></li></ul><ul id="d8cff1f6-dc98-48ac-b7b3-029e7526db0e" class="toggle"><li><details open=""><summary>Micro kernel</summary><p id="626c04cb-2ece-4502-82cd-a60a53de5cdb" class="">a. Only major functions are in kernel.<br/>i. Memory mgmt.<br/>ii. Process mgmt.<br/>b. File mgmt. and IO mgmt. are in User-space.<br/>c. smaller in size.<br/>d. More Reliable<br/>e. More stable<br/>f. Performance is slow.<br/>g. Overhead switching b/w user mode and kernel mode.<br/>h. Eg. L4 Linux, Symbian OS, MINIX etc.<br/></p></details></li></ul><ul id="75ece09d-465d-4269-993c-cd7cad9d6cbe" class="toggle"><li><details open=""><summary>hybrid kernel</summary><ul id="8f6749d8-7deb-4c3b-9ad0-c197c946d332" class="bulleted-list"><li style="list-style-type:disc"><strong>Advantages of both worlds:</strong> It combines the speed and design of a monolithic kernel with the modularity and stability of a microkernel.</li></ul><ul id="441c5c4c-ad6f-48e8-82b5-9120cb5faf54" class="bulleted-list"><li style="list-style-type:disc"><strong>Combined approach:</strong> It uses a combination of monolithic and microkernel techniques.</li></ul><ul id="c3fe28b2-af7e-4c47-abf9-9c4e28c2cc53" class="bulleted-list"><li style="list-style-type:disc"><strong>Speed and design of monolithic:</strong> It is fast and has a simple design.</li></ul><ul id="8edcb3ad-fb93-465c-972f-b44d72419ff0" class="bulleted-list"><li style="list-style-type:disc"><strong>Modularity and stability of microkernel:</strong> It is modular and stable.</li></ul><ul id="58cd684d-fca6-4d6f-b4af-355a01313a02" class="bulleted-list"><li style="list-style-type:disc"><strong>Examples:</strong> MacOS, Windows NT/7/10</li></ul></details></li></ul></details></li></ul><ul id="e18d3882-fa34-4525-861d-0f54d92ab935" class="toggle"><li><details open=""><summary>Inter process communication(IPC) → Communication between userspace and kernel</summary><p id="9c4a1779-531f-44f0-a3ca-82eae0e6289c" class="">Inter-Process Communication (IPC) is a set of mechanisms that allow processes to communicate with each other and synchronize their actions. IPC is crucial for enabling cooperation between different processes in a multi-tasking operating system</p><h3 id="2a7239b4-ddad-4285-bed1-6e9c7c048de4" class="">Purpose of IPC:</h3><ul id="b729860d-618f-429d-8dd7-b7f3fc5c6b32" class="bulleted-list"><li style="list-style-type:disc">Share data between processes</li></ul><ul id="ce4be2aa-8b77-443a-917b-88e511a9dd86" class="bulleted-list"><li style="list-style-type:disc">Synchronize actions of different processes</li></ul><ul id="1833faf4-4377-436d-b2db-033ca6de68d1" class="bulleted-list"><li style="list-style-type:disc">Notify processes about events</li></ul><ul id="52cec5ae-560b-4317-a503-ebe10b3958b7" class="bulleted-list"><li style="list-style-type:disc">Share resources efficiently</li></ul><h3 id="16f8f341-b0f7-417f-9458-104e5993fa2a" class="">Mechanisms</h3><p id="08d5f387-ce2b-4fb9-a83c-fa1b1a2072a0" class="">a) Pipes:</p><ul id="44f21e4f-338e-4cd1-9336-0457f8cfc1ed" class="bulleted-list"><li style="list-style-type:disc">Unidirectional data channel</li></ul><ul id="9ea2673a-bce4-4eb4-a764-baddfc007963" class="bulleted-list"><li style="list-style-type:disc">Often used between parent and child processes</li></ul><ul id="6b9bc784-de20-4056-9e3b-ae3ccf9b8430" class="bulleted-list"><li style="list-style-type:disc">Example: Unix pipe (|) in shell commands</li></ul><p id="55b50645-671d-4e41-af47-b6b3fb66f910" class="">b) Message Queues:</p><ul id="2083f478-f8a5-485f-9518-3f5cb7dc4580" class="bulleted-list"><li style="list-style-type:disc">Allows processes to exchange messages</li></ul><ul id="af23b123-3be3-405c-8e45-b9fb8ff090e7" class="bulleted-list"><li style="list-style-type:disc">Messages are stored in a queue until received</li></ul><p id="84b5ba28-4ee9-43c3-9818-94330547596f" class="">c) Shared Memory:</p><ul id="8f7c2539-f11e-4bc6-bc10-670cd457fa9e" class="bulleted-list"><li style="list-style-type:disc">Fastest IPC method</li></ul><ul id="b9a9546a-9d64-48de-a4e6-644b1c7573aa" class="bulleted-list"><li style="list-style-type:disc">Multiple processes can access the same memory segment</li></ul><ul id="0f93a5dd-ed04-4d95-bb08-28c9612182d8" class="bulleted-list"><li style="list-style-type:disc">Requires careful synchronization</li></ul><p id="291b49d8-e6fd-4911-a3f5-513e88118b57" class="">d) Semaphores:</p><ul id="436416e3-5a66-4c74-a5ef-8858e4cf00e2" class="bulleted-list"><li style="list-style-type:disc">Used for synchronization between processes</li></ul><ul id="78b17e27-7fba-426a-8d47-81b6ee56e52b" class="bulleted-list"><li style="list-style-type:disc">Can control access to shared resources</li></ul><p id="c9aef448-74a8-4309-babd-af165a5af08d" class="">e) Sockets:</p><ul id="d2d33636-a03c-4713-9881-a5f014f647d0" class="bulleted-list"><li style="list-style-type:disc">Can be used for IPC on the same machine or across a network</li></ul><ul id="adb5b9b3-3cf2-442f-865e-88f1e0e8f751" class="bulleted-list"><li style="list-style-type:disc">Versatile and widely used in distributed systems</li></ul><p id="c2adc266-24ef-473e-b312-8532be555eea" class="">f) Signals:</p><ul id="9a3c49b5-7380-422d-814e-7dd81e60cd29" class="bulleted-list"><li style="list-style-type:disc">Used to notify a process of a particular event</li></ul><ul id="8ed11c71-8680-4463-b97d-e560aaa55827" class="bulleted-list"><li style="list-style-type:disc">Limited in the amount of information they can carry</li></ul><p id="56a7ca16-1c8b-4b6e-8f84-222109ce2ca2" class="">g) Memory-mapped Files:</p><ul id="5b4d3f8f-a1d0-4585-9142-86a8a31e4f10" class="bulleted-list"><li style="list-style-type:disc">A file is mapped to memory and can be accessed as if it were an array</li></ul><h3 id="925c6313-67e7-4eca-a08d-ae5f25b1b581" class="">Advantages of IPC:</h3><ul id="bdc507fa-c415-4fa4-9b39-b09ec51f3a63" class="bulleted-list"><li style="list-style-type:disc">Allows for modular system design</li></ul><ul id="16af2d34-e133-4750-b391-41466794daa4" class="bulleted-list"><li style="list-style-type:disc">Enables parallel processing</li></ul><ul id="5ec993fe-c968-41ff-9271-3bdf0bfaeec2" class="bulleted-list"><li style="list-style-type:disc">Facilitates client-server architectures</li></ul><h3 id="95bd0935-0658-4f9b-854a-3bd686f19423" class="">Challenges in IPC:</h3><ul id="2377e241-15a3-44f7-a52d-7f463e664dbf" class="bulleted-list"><li style="list-style-type:disc">Synchronization issues</li></ul><ul id="7e52a247-1e63-4294-b08a-06140404b5e4" class="bulleted-list"><li style="list-style-type:disc">Potential deadlocks</li></ul><ul id="74238e16-b996-409a-a72d-fa3d2e7a3852" class="bulleted-list"><li style="list-style-type:disc">Overhead in some IPC mechanisms</li></ul><ul id="0fb4bca0-43a0-40fb-9bf2-8c1bd2f74ed7" class="bulleted-list"><li style="list-style-type:disc">Security considerations when sharing data</li></ul></details></li></ul><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">System calls</summary><div class="indented"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="78f1128d-2f50-4316-896b-a2337ab053c8"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">We can get starting code in unix based systems using <code>man 2 &lt;system call name&gt;</code> <br/><br/><code>man 2 pipe</code></div></figure><p id="90a1abee-d4b8-4c49-9618-7e145581a0f6" class="">Its an interface used by the applications in userspace to talk with the kernel space as kernel space is having access to the hardware.</p><ul id="cf23be0b-d467-4e83-93f2-fe0dd7295e27" class="toggle"><li><details open=""><summary>Intro</summary><p id="ce092b4a-b55d-4d73-b9a7-0a0f705b64d6" class="">A system call is used by application (user)<br/>programs to request service from the<br/>operating system.<br/>• Switch to kernel mode.(higher privilege)<br/>• Required to ensure security<br/></p></details></li></ul><ul id="dd819cb8-4904-4b96-a94e-fde57a6b6a2b" class="toggle"><li><details open=""><summary>Workflow</summary><p id="6f88aa06-e569-4116-9293-5014ebad7f8d" class="">Suppose we want to read a file</p><ul id="1a41f405-5130-4404-ad7f-66bbc854cba1" class="bulleted-list"><li style="list-style-type:disc">User program:<br/>The program (running in user mode) needs to read data from a file.<br/></li></ul><ul id="ea81573e-2f48-4da4-baf5-21e3dcb43e58" class="bulleted-list"><li style="list-style-type:disc">System call invocation:<br/>The program makes a system call, like <br/><code>read()</code>, with appropriate parameters (file descriptor, buffer, number of bytes to read).</li></ul><ul id="519393ee-271d-43bb-aac1-816d64f6036b" class="bulleted-list"><li style="list-style-type:disc">Trap to kernel mode:<br/>The system call causes a <br/><strong><span style="border-bottom:0.05em solid">trap (software interrupt)</span></strong> that switches the CPU from user mode to kernel mode.</li></ul><ul id="d7f45cd2-b976-48b9-bbd7-23669621a5fe" class="bulleted-list"><li style="list-style-type:disc">Kernel handles the system call:<br/>The kernel&#x27;s system call handler takes over and processes the request.<br/></li></ul><ul id="4b87ce1a-9fe7-4945-a640-6e75cb0f8eb9" class="bulleted-list"><li style="list-style-type:disc">File system interaction:<br/>The kernel interacts with the file system to retrieve the requested data.<br/></li></ul><ul id="8746bc3a-2b32-4038-9ff0-46ecd974d028" class="bulleted-list"><li style="list-style-type:disc">Data transfer:<br/>The kernel copies the data from the kernel space to the user space buffer.<br/></li></ul><ul id="a2ae3cfc-1e95-4de1-ae3e-46d71043426d" class="bulleted-list"><li style="list-style-type:disc">Return to user mode:<br/>The kernel switches the CPU back to user mode and returns control to the user program.<br/></li></ul><ul id="e1a775cb-81c1-4b19-931d-1b143864f90d" class="bulleted-list"><li style="list-style-type:disc">Program continues:<br/>The user program resumes execution with the requested data now available in its buffer.<br/><ul id="afef764d-fe1e-4d50-85e5-ade5cc5969f9" class="bulleted-list"><li style="list-style-type:circle"><code>open()</code> is a system call to open the file.</li></ul><ul id="c3c01a88-5265-4178-b609-4acd4748a621" class="bulleted-list"><li style="list-style-type:circle"><code>read()</code> is a system call to read from the file.</li></ul><ul id="e84ae6b8-b4dd-4a8e-993d-31ff953c466c" class="bulleted-list"><li style="list-style-type:circle"><code>close()</code> is a system call to close the file.</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5cd99736-1293-4137-8b23-f545da324a0b" class="code"><code class="language-YAML">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    char buffer[100];
    int fd = open(&quot;example.txt&quot;, O_RDONLY);  // System call: open
    ssize_t bytes_read = read(fd, buffer, sizeof(buffer));  // System call: read
    close(fd);  // System call: close
    return 0;
}</code></pre></li></ul></details></li></ul><ul id="3523cce7-ebe6-4c86-9268-af26ec549b02" class="toggle"><li><details open=""><summary>Types</summary><figure id="ad6c425a-7296-4b88-b828-761fc619c651" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Untitled%204.png"><img style="width:652.0596313476562px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Untitled%204.png"/></a></figure><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">fork</summary><div class="indented"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="4c031647-0f23-4c77-9abe-2d1b933f0292"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Changing something in parent will not affect child</div></figure><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">description</summary><div class="indented"><figure id="d80fc450-c033-4026-a704-1889936db603" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/image.png"><img style="width:421px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/image.png"/></a></figure><p id="5488e8e6-4866-4b14-85c1-4953762e1b42" class="">The Fork system call is used for creating a new process in Linux, and Unix systems, which is called the <em><strong>child process</strong></em>, which runs concurrently with the process that makes the fork() call (parent process). After a new child process is created, both processes will execute the next instruction following the fork() system call.</p><p id="eaac040b-0782-4631-8cce-90eefda1ec56" class="">The child process uses the same pc(program counter), same CPU registers, and same open files which use in the parent process. It takes no parameters and returns an integer value.</p><p id="253c49c2-03b1-4c20-a13a-a0e68690031e" class="">Below are different values returned by fork().</p><ul id="bbc33f70-a0eb-4227-9d47-e95fd0af1fdd" class="bulleted-list"><li style="list-style-type:disc"><em><strong>Negative Value</strong></em>: The creation of a child process was unsuccessful.</li></ul><ul id="546ba772-6f54-4da2-9470-4e86697a7cb2" class="bulleted-list"><li style="list-style-type:disc"><em><strong>Zero</strong></em>: Returned to the newly created child process.</li></ul><ul id="4b23b450-1b49-4d2a-b353-90517fc58d3f" class="bulleted-list"><li style="list-style-type:disc"><em><strong>Positive value</strong></em>: Returned to parent or caller. The value contains the process ID of the newly created child process.</li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">distinguishing parent, child and failed process</summary><div class="indented"><ul id="a9808a77-f825-45ff-92f0-b32ab91bf271" class="bulleted-list"><li style="list-style-type:disc"><em><strong>Negative Value</strong></em>: The creation of a child process was unsuccessful.</li></ul><ul id="a2f9f8a6-e46c-4935-ab39-cbf91fb99de3" class="bulleted-list"><li style="list-style-type:disc"><em><strong>Zero</strong></em>: Returned to the newly created child process.</li></ul><ul id="724e05e0-5188-4a30-a197-dd3fc992a20f" class="bulleted-list"><li style="list-style-type:disc"><em><strong>Positive value</strong></em>: Returned to parent or caller. The value contains the process ID of the newly created child process.</li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">number of processes</summary><div class="indented"><p id="eaa5e261-45cc-4937-ab6e-51c6709e21be" class="">Number of Processes = 2n, where n is the number of fork system calls. </p></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">calling multiple fork() and the relation</summary><div class="indented"><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f5ab8ed6-bf6e-4f4b-a50d-f07f49cdea98" class="code"><code class="language-YAML">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main() {
    fork();
    fork();
    fork();
    
    printf(&quot;Process ID: %d, Parent ID: %d\n&quot;, getpid(), getppid());
    return 0;
}</code></pre><h3 id="65f5213c-81fa-415a-a601-978e4cb1ddd9" class="">Process breakdon</h3><ul id="05eafcc3-8c92-4d9f-abe5-f19f7cc68ab6" class="bulleted-list"><li style="list-style-type:disc"><strong>Initial Process (Process A)</strong>:<ul id="c8b87225-33ae-4199-9469-19e0ec8c2dc6" class="bulleted-list"><li style="list-style-type:circle">Starts executing the program.</li></ul></li></ul><ul id="838f3ab4-91dd-4ba4-990e-f46799e7412d" class="bulleted-list"><li style="list-style-type:disc"><strong>First </strong><code><strong>fork()</strong></code>:<ul id="36d0d22e-63f1-4460-80fd-10ee247ca87a" class="bulleted-list"><li style="list-style-type:circle">Process A creates a child process (Process B).</li></ul><ul id="4bf8aef9-1acc-4449-8156-e2c835d70b6b" class="bulleted-list"><li style="list-style-type:circle">Now there are two processes: Process A and Process B.</li></ul></li></ul><ul id="10bcd544-659d-4b33-94c5-2373ff1166f6" class="bulleted-list"><li style="list-style-type:disc"><strong>Second </strong><code><strong>fork()</strong></code>:<ul id="7d22516d-6f43-4a75-a051-e889a43d4a47" class="bulleted-list"><li style="list-style-type:circle">Both Process A and Process B execute this <code>fork()</code>, each creating a new child process.</li></ul><ul id="602e1f5c-c1c3-480a-a9c1-ebf7dd77bb69" class="bulleted-list"><li style="list-style-type:circle">Process A creates Process C.</li></ul><ul id="ca579dd5-a767-4ad4-b92a-a2d4403ac3ca" class="bulleted-list"><li style="list-style-type:circle">Process B creates Process D.</li></ul><ul id="76115c71-e525-4b2b-ad5c-aea6ae093915" class="bulleted-list"><li style="list-style-type:circle">Now there are four processes: A, B, C, D.</li></ul></li></ul><ul id="14ada630-f204-4823-ae6a-a262c27043d7" class="bulleted-list"><li style="list-style-type:disc"><strong>Third </strong><code><strong>fork()</strong></code>:<ul id="4c134796-6902-402a-be2b-98e4367797c6" class="bulleted-list"><li style="list-style-type:circle">All four processes (A, B, C, D) execute this <code>fork()</code>, each creating a new child process.</li></ul><ul id="14e83d50-e27f-4345-baf4-723d14ddca1e" class="bulleted-list"><li style="list-style-type:circle">Process A creates Process E.</li></ul><ul id="4207b175-413f-46f9-a341-58748a72e9f3" class="bulleted-list"><li style="list-style-type:circle">Process B creates Process F.</li></ul><ul id="09391f0d-32c6-4ad3-b5bc-13a15bd39e58" class="bulleted-list"><li style="list-style-type:circle">Process C creates Process G.</li></ul><ul id="0801c3d7-5aec-44bf-8e1b-1d4104ce777c" class="bulleted-list"><li style="list-style-type:circle">Process D creates Process H.</li></ul><ul id="703dbcfe-1565-48c7-8aae-4179ed0434e7" class="bulleted-list"><li style="list-style-type:circle">Now there are eight processes: A, B, C, D, E, F, G, H.</li></ul></li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">Processes are independent , orphaned process and termination</summary><div class="indented"><h3 id="19579b71-d42f-4b51-891e-76be54613d8f" class="">Process Tree:</h3><p id="2df6c575-6f73-4483-bacb-03a3e8b8a30d" class="">Process A (original)<br/>├── Process B (fork1 from A)<br/>│   ├── Process D (fork2 from B)<br/>│   └── Process F (fork3 from B)<br/>├── Process C (fork2 from A)<br/>│   ├── Process E (fork3 from A)<br/>│   └── Process G (fork3 from C)<br/><br/></p><p id="22a418c8-7813-4990-8490-a848011e226a" class="">We called three forks</p><h3 id="c4a7c258-5bbf-4758-a47d-4dea9a68cdde" class="">But closing Process B closes Process D and F??</h3><ul id="6f35ff8b-8601-4fb9-8974-50a9fe70ac6d" class="bulleted-list"><li style="list-style-type:disc"><strong>Process D</strong> is created by Process B when it calls the second <code>fork()</code>.</li></ul><ul id="f4eedaf5-85a7-45ea-9c0d-95a304d2eaa8" class="bulleted-list"><li style="list-style-type:disc"><strong>Process F</strong> is created by Process B when it calls the third <code>fork()</code>.</li></ul><p id="043a8329-ccae-4baa-8791-f13f2427a5bd" class="">However, once a child process like Process D or Process F is created, it is an independent process. The termination of the parent process (Process B, in this case) does not automatically terminate the child processes (Process D and Process F).</p><h3 id="1812951e-b066-4314-b2af-60aa17c2dedd" class="">What Happens When Process B Terminates?</h3><ul id="0999e3a9-80c1-47db-b943-9bd0cbb1c38e" class="bulleted-list"><li style="list-style-type:disc"><strong>Orphan Processes</strong>: When a parent process (e.g., Process B) terminates before its child processes (e.g., Process D and F), the child processes become &quot;orphan&quot; processes.</li></ul><ul id="bb2cfa34-dd2f-41a4-a42f-1e52a0a3462a" class="bulleted-list"><li style="list-style-type:disc"><strong>Reassignment to Init/Systemd</strong>: On Unix-like systems, orphaned child processes are typically adopted by the <code>init</code> process (with PID 1, or in some systems, <code>systemd</code>). This process becomes the new parent of the orphaned processes. The orphaned processes continue running independently.</li></ul><ul id="29f477e8-075f-42ce-94da-0a026fcb64f1" class="bulleted-list"><li style="list-style-type:disc">The only time a child process would stop immediately when its parent process terminates is if the child process was designed to do so explicitly, but that is not the default behavior in Unix-like operating systems.</li></ul></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">pipe → for ipc</summary><div class="indented"><p id="24a9bb42-6bb0-47a3-a040-59b8acbe6dfe" class="">a pipe is a connection between two processes, such that the standard output from one process becomes the standard input of the other process. In UNIX Operating System, Pipes are useful for communication between related processes(inter-process communication).</p><ol type="1" id="7e5739dd-eef7-401f-9996-cb5eedc93bc3" class="numbered-list" start="1"><li>One process write to a pipe and other process read from the pipe. A one-way communication</li></ol><ol type="1" id="4703036f-12a3-4914-be43-ab6e1ca1fbf6" class="numbered-list" start="2"><li>If a process tries to read before something is written to the pipe, the process is suspended until something is written.</li></ol><ol type="1" id="ab1344fe-ee98-4291-8fe1-7f837da64943" class="numbered-list" start="3"><li>The pipe system call finds the first two available positions in the process’s open file table and allocates them for the read and write ends of the pipe.</li></ol><figure id="84e28701-fb9b-4f82-8b51-7f4f93aeeff3" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Process.jpg"><img style="width:392px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/Process.jpg"/></a></figure><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">creating pipe</summary><div class="indented"><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0c597ed0-328e-4e81-a492-72f291594c88" class="code"><code class="language-YAML">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(){
    // file descriptor array
    // read and write
    int pipefds[2];
    int status = pipe(pipefds);
    if(status == -1){
        perror(&quot;pipe&quot;);
        exit(EXIT_FAILURE);
    }

    printf(&quot;Read file descriptor value, %d\n&quot;,pipefds[0]);
    printf(&quot;Write file descriptor value, %d\n&quot;,pipefds[1]);
}
</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">working</summary><div class="indented"><p id="bca0f05a-6a0f-4efe-9e00-d8418b832074" class="">Yes, the <code>pipe()</code> system call in Unix-like operating systems creates two file descriptors that represent the two ends of a pipe. Here&#x27;s a more detailed explanation:</p><h3 id="b4347d52-829c-4e95-b5e5-6d589e5591e1" class="">How <code>pipe()</code> Works</h3><ul id="4b120743-0cad-4e01-a0e1-61646e7ef9fd" class="bulleted-list"><li style="list-style-type:disc"><strong>Purpose</strong>: The <code>pipe()</code> system call is used to create a unidirectional data channel (pipe) that can be used for communication between processes. It provides a way for one process to send data to another process.</li></ul><ul id="5b944eb3-c8c4-4a86-8bac-2470b8eb6307" class="bulleted-list"><li style="list-style-type:disc"><strong>File Descriptors</strong>:<ul id="9e6dcaf4-eed2-4a30-ab7c-3809e1931298" class="bulleted-list"><li style="list-style-type:circle"><strong>File Descriptor Array</strong>: <code>pipe()</code> takes an array of two integers as an argument, typically named <code>pipefds</code> in code. The array will be populated with two file descriptors:<ul id="8c4848b2-fe82-4fde-85ec-aabf30b0b35c" class="bulleted-list"><li style="list-style-type:square"><code>pipefds[0]</code>: The file descriptor for the <strong>read</strong> end of the pipe.</li></ul><ul id="ff9eb838-e781-4ab2-865b-266774b04531" class="bulleted-list"><li style="list-style-type:square"><code>pipefds[1]</code>: The file descriptor for the <strong>write</strong> end of the pipe.</li></ul><ul id="e4c24723-8683-48f6-b5e2-9cfd02b89036" class="bulleted-list"><li style="list-style-type:square"><strong>Write to Pipe</strong>: Use the <code>write()</code> system call on <code>pipefds[1]</code> to send data into the pipe.</li></ul><ul id="1412e333-e6ce-48a1-a943-f27c0640b4ce" class="bulleted-list"><li style="list-style-type:square"><strong>Read from Pipe</strong>: Use the <code>read()</code> system call on <code>pipefds[0]</code> to receive data from the pipe.</li></ul><ul id="5b9da572-fc25-4a56-9c61-91e8c5b6f085" class="bulleted-list"><li style="list-style-type:square">Always close file descriptors when they are no longer needed to prevent resource leaks. For example, after the communication is complete, you should close both ends of the pipe.</li></ul></li></ul></li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">read end is coming 3 and write end is coming 4</summary><div class="indented"><p id="bc9ee751-c1da-4815-b405-742dc6203ca6" class="">The reason your program prints <code>3</code> and <code>4</code> for the file descriptors in the <code>pipefds</code> array is due to how file descriptors work in Unix-like operating systems (such as Linux or macOS).</p><h3 id="b6a88e3b-9e54-467a-a82c-879594c4978c" class="">File Descriptors in Unix-like Systems:</h3><ul id="6d0f638a-ab2d-4f6c-abe2-fd2e668ccf74" class="bulleted-list"><li style="list-style-type:disc"><strong>File descriptors</strong> are small integers that the operating system uses to keep track of open files (including pipes, sockets, etc.).</li></ul><ul id="6db608e1-060e-480e-8290-bc3ceffc6784" class="bulleted-list"><li style="list-style-type:disc">By convention, the first three file descriptors are:<ol type="1" id="25ff9948-541e-473b-b883-b1f45a1b5bd3" class="numbered-list" start="1"><li><code>0</code> - Standard input (stdin)</li></ol><ol type="1" id="050c2d64-50ac-461a-b0a2-e8aa52c8b066" class="numbered-list" start="2"><li><code>1</code> - Standard output (stdout)</li></ol><ol type="1" id="67619a95-22c9-4b60-8d74-37884a764a10" class="numbered-list" start="3"><li><code>2</code> - Standard error (stderr)</li></ol></li></ul><p id="51f74096-0faf-4457-bec7-ba0616f7c169" class="">When you create a new file descriptor (such as by opening a file, creating a pipe, etc.), the operating system assigns it the lowest available integer greater than or equal to 3.</p></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">suspension of task when reading from pipe</summary><div class="indented"><p id="90938631-88fe-44e5-a287-a8e78edff409" class=""> you can create a simple program where the parent process writes to the pipe and the child process reads from it. The child process will attempt to read before the parent process writes any data to the pipe, causing the child process to be suspended until data is written.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="13a34697-a683-460f-9bb0-ec28e8f9bc63" class="code"><code class="language-YAML">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int pipefds[2];
    char buffer[6]; // 5 bytes + 1 null terminator

    // Create the pipe
    if (pipe(pipefds) == -1) {
        perror(&quot;pipe&quot;);
        exit(EXIT_FAILURE);
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror(&quot;fork&quot;);
        exit(EXIT_FAILURE);
    }

    if (pid == 0) { // Child process
        close(pipefds[1]); // Close unused write end

        // Attempt to read from the pipe before the parent writes anything
        printf(&quot;Child: Attempting to read from the pipe...\n&quot;);
        ssize_t bytesRead = read(pipefds[0], buffer, 5);
        if (bytesRead &gt; 0) {
            buffer[bytesRead] = &#x27;\0&#x27;; // Null terminate the string
            printf(&quot;Child: Received &#x27;%s&#x27;\n&quot;, buffer);
        } else {
            printf(&quot;Child: No data received or error occurred\n&quot;);
        }

        close(pipefds[0]); // Close read end after reading
        exit(EXIT_SUCCESS);
    } else { // Parent process
        close(pipefds[0]); // Close unused read end

        // Sleep for 5 seconds to simulate delayed writing
        sleep(5);

        // Write data to the pipe
        const char *message = &quot;Hello&quot;;
        write(pipefds[1], message, 5);

        printf(&quot;Parent: Data written to the pipe\n&quot;);

        close(pipefds[1]); // Close write end after writing
        wait(NULL); // Wait for the child process to finish
    }

    return 0;
}
</code></pre></div></details></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">interprocess communication demonstration using pipe, fork and wait</summary><div class="indented"><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="cfda04cf-3a10-49a8-a410-48c72c87a9d4" class="code"><code class="language-YAML">// inter process communication
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(){
    int pipefds[2];
    char *pin;
    char buffer[5];
    if(pipe(pipefds) == -1){
        perror(&quot;pipe&quot;);
        exit(EXIT_FAILURE);
    }
    pid_t pid = fork();
    if(pid == 0){
        pin = &quot;12345\0&quot;;
        write(pipefds[1],pin,5);
        printf(&quot;Writing in child and sending to parent\n&quot;);
        sleep(3); // intentional delay
        exit(EXIT_SUCCESS);
    }
    else if(pid&gt;0){
        wait(NULL); // waiting for child to finish
        read(pipefds[0],buffer,5); // reading from pipe and storing it in buffer

        printf(&quot;Received PIN %s\n&quot;,buffer);
    }
    return 0;
}</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">blocking io in c</summary><div class="indented"><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7aa1458a-bc37-4ff0-9848-1c8c90391bc8" class="code"><code class="language-YAML">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
    int pipefd[2]; // Array to hold pipe file descriptors
    pid_t cpid;
    char buf;
    
    // Create a pipe
    if (pipe(pipefd) == -1) {
        perror(&quot;pipe&quot;);
        exit(EXIT_FAILURE);
    }

    // Fork a child process
    cpid = fork();
    if (cpid == -1) {
        perror(&quot;fork&quot;);
        exit(EXIT_FAILURE);
    }

    if (cpid == 0) {    // Child process
        close(pipefd[1]);  // Close unused write end

        // Read from pipe (blocking)
        while (read(pipefd[0], &amp;buf, 1) &gt; 0) {
            write(STDOUT_FILENO, &amp;buf, 1);
        }

        write(STDOUT_FILENO, &quot;\n&quot;, 1);
        close(pipefd[0]);
        _exit(EXIT_SUCCESS);

    } else {            // Parent process
        close(pipefd[0]);  // Close unused read end

        // Write to pipe
        const char *msg = &quot;Hello from parent to child!&quot;;
        write(pipefd[1], msg, strlen(msg));

        close(pipefd[1]);  // Reader will see EOF
        wait(NULL);        // Wait for child process to finish
        exit(EXIT_SUCCESS);
    }
}
</code></pre><p id="dcab02dd-ccd7-4dd4-bee1-9df90e12acbb" class="">Working</p><ul id="827580d6-83ea-40ec-a509-038405335c92" class="bulleted-list"><li style="list-style-type:disc"><strong>Pipe Creation</strong>: The <code>pipe(pipefd)</code> function creates a pipe and returns two file descriptors: <code>pipefd[0]</code> for reading and <code>pipefd[1]</code> for writing.</li></ul><ul id="177eed77-e2fc-477f-b41a-434045064e6a" class="bulleted-list"><li style="list-style-type:disc"><strong>Forking</strong>: A child process is created using <code>fork()</code>. The child process inherits the pipe file descriptors from the parent.</li></ul><ul id="0c1300d8-6b29-4261-b2cc-eae83a7eee1e" class="bulleted-list"><li style="list-style-type:disc"><strong>Blocking Read</strong>: In the child process, the <code>read(pipefd[0], &amp;buf, 1)</code> function call will block until data is available to read from the pipe.</li></ul><ul id="ceeb3f2f-bd5d-4039-af9f-74ef4540c0f5" class="bulleted-list"><li style="list-style-type:disc"><strong>Writing to Pipe</strong>: The parent process writes a message to the pipe using <code>write(pipefd[1], msg, strlen(msg))</code>.</li></ul><ul id="8c7af09b-ea85-454f-849d-cf37543c9cc2" class="bulleted-list"><li style="list-style-type:disc"><strong>Process Termination</strong>: The parent waits for the child process to finish reading from the pipe.</li></ul><p id="e433fe21-89dc-4f70-90bb-ed4f3d603504" class="">Blocking io</p><ul id="8c14c7ad-d8d7-4d19-92b0-935d16d5037d" class="bulleted-list"><li style="list-style-type:disc">By default, reading from a pipe will block the process until data is available. Writing to a pipe will also block if the pipe&#x27;s buffer is full.</li></ul><ul id="33424194-d712-4a1b-b831-f5911c502923" class="bulleted-list"><li style="list-style-type:disc"><strong>Blocking Behavior</strong>: The <code>read()</code> system call blocks the process until data is available. If no data is written to the pipe, the child process will wait indefinitely.</li></ul><ul id="f9e8fb25-2975-4cd7-8d0d-3084e0066969" class="bulleted-list"><li style="list-style-type:disc"><strong>EOF Signal</strong>: When the parent closes the write end of the pipe, the child process reading from the pipe will receive an end-of-file (EOF) signal, and the <code>read()</code> call will return 0.</li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">how any shell command works behind the scenes with system calls</summary><div class="indented"><ul id="c5a9ebcd-6ab5-416c-bdb3-4247546393aa" class="bulleted-list"><li style="list-style-type:disc">Shell is a process waiting for our input</li></ul><ul id="fcbb245b-7b38-48ee-9c9b-36ebac28347a" class="bulleted-list"><li style="list-style-type:disc">When run anything , it creates or fork a child process and then child runs</li></ul><ul id="2aa25c0e-e961-41d7-91a5-05470d7b3daf" class="bulleted-list"><li style="list-style-type:disc">Parent wait for the pid using call <code>waitpid</code> waiting for a specific process id<figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="426088ba-54a6-4f78-b64f-53c600dc5c3a"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">waitpid(pid_t <em>pid</em>, int *<em>status_ptr</em>, int <em>options</em>)</div></figure></li></ul><ul id="a7bd93cf-ac46-4189-b877-0a9f1d96dbf1" class="bulleted-list"><li style="list-style-type:disc">Untill that process is over or that specific child process is complete we can’t run other system call. If we run it will run in the child and not in the parent that is the shell</li></ul><ul id="6e0df711-7ea8-4788-9822-22d1b32b5b51" class="bulleted-list"><li style="list-style-type:disc">After the child process is completed the address pointed out by the <code>statloc</code> will have child termination status.</li></ul><ul id="7ee2c1dd-5705-4b78-ab55-c8cb3e09e98e" class="bulleted-list"><li style="list-style-type:disc">Child process executes the user command by using <code>execv</code> system call<figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="8a3b40a5-9d17-47dd-8187-877188f6298d"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">int execve(const char *filename, char *const argv[],<br/>char *const envp[]);<br/></div></figure></li></ul><p id="9d84bf59-cefd-44d9-a030-49f120e3575b" class="">
</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7aed4f6d-8890-422d-8329-17acfa5e8904" class="code"><code class="language-YAML">Inside shell -&gt; parent
mkdir foldername -&gt; command  -&gt; child process
execve(...args)</code></pre></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">exit</summary><div class="indented"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="07302e30-c263-4062-a749-5dadbf2ff480"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">exit(status)<br/>// status → 0 to 255<br/></div></figure><p id="992b4fe2-140d-40e6-bdba-140d33f9dd23" class="">Used by the processes to termininate/exit</p><p id="6c0354c6-8e1a-4c94-a07b-df69e1e891a3" class="">status is returned to the address pointed out by the <code>&amp;statloc</code> and will be returned to the parent</p><p id="11ed3456-f72f-45ab-b11c-243f0855d9d8" class="">Lower value like means 0 means normal exit and higher represents error</p></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">system calls for signalling</summary><div class="indented"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="e07ce55a-9515-4359-a2fd-e96b159a172d"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">sigaction → new<br/>signal → old<br/></div></figure><ul id="c4dac1bc-214e-46ce-ae9f-ae504ca59dc5" class="toggle"><li><details open=""><summary>signals in os</summary><p id="331881fc-1f74-4dfd-a6f0-bfa2d3b0bb3d" class="">A <strong><a href="https://www.geeksforgeeks.org/program-error-signals/">signal </a></strong>is a message or notification issued to your program by the<strong><a href="https://www.geeksforgeeks.org/introduction-of-operating-system-set-1/"> operating system</a></strong> or another application (or one of its threads). Each signal is assigned a number between 1 and 31. Signals are devoid of argument, and most of the time, their names are self-explanatory. For instance, signal number 9 or SIGKILL notifies the program that it is being attempted to be killed.</p></details></li></ul><ul id="81fc5f48-2982-4bc0-aa87-adf2085fb9fd" class="toggle"><li><details open=""><summary>sigaction system call</summary><p id="0be7ee33-d2b6-4f13-9064-6595fbc95d97" class="">The sigaction() system call is used to change the action taken by a process on receipt of a specific signal.<br/>signum specifies the signal and can be any valid signal except SIGKILL and SIGSTOP.<br/></p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="8a29b058-c3cf-4a13-9bf6-0c4b2491b229"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</div></figure></details></li></ul><ul id="984a7b7e-b654-4c6a-a4d1-aad10b912651" class="toggle"><li><details open=""><summary>signal system call</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="71d20808-4143-422f-9d38-a45e1780debd" class="code"><code class="language-YAML">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

void handleSignal(int signal)
{
    if (signal == SIGINT)
    {
        printf(&quot;exiting...&quot;);
        // now we will not able to exit the program as we are not exiting
        // exit(0); // enable it to exit
    }
}

int main()
{
    signal(SIGINT, handleSignal);
    while (1)
    {
        printf(&quot;Program running. Press Ctrl+C to stop.\n&quot;);
        sleep(1); // Sleep for a second
    }
    return 0;
}</code></pre></details></li></ul><ul id="fa9465f0-d1c4-44e9-b9a0-7fd0913ec205" class="toggle"><li><details open=""><summary>How ctrl + c works and it stops the current process??</summary><p id="5edef7f2-0003-40c8-bd86-aa2606aff98f" class="">When a process is running and the user presses Ctrl+C, the following sequence of events occurs using signals:</p><ol type="1" id="79374e7e-c538-4cf4-8908-4fc71f169287" class="numbered-list" start="1"><li><strong>Signal Generation</strong>:<ul id="90bb240e-0f8b-40f5-812d-c851e7682267" class="bulleted-list"><li style="list-style-type:disc">The terminal driver (part of the operating system) detects the Ctrl+C key combination and generates the <code>SIGINT</code> (Interrupt) signal.</li></ul><ul id="3b66042b-395d-4ad2-97b1-5e697525e1d3" class="bulleted-list"><li style="list-style-type:disc">The <code>SIGINT</code> signal is then delivered to the running process.</li></ul></li></ol><ol type="1" id="2e1d538b-039b-4d0a-911b-58d151db2ed2" class="numbered-list" start="2"><li><strong>Signal Handling</strong>:<ul id="0594f949-2608-4126-851d-aa172ff560ea" class="bulleted-list"><li style="list-style-type:disc">By default, the <code>SIGINT</code> signal is configured to terminate the process.</li></ul><ul id="2a80cafd-c92c-4e78-8e5d-dec844f8533a" class="bulleted-list"><li style="list-style-type:disc">However, the process can choose to handle the <code>SIGINT</code> signal by using the <code>sigaction()</code> system call to specify a custom signal handler function.</li></ul><ul id="5ce72506-6618-4178-acff-bd1e7564316c" class="bulleted-list"><li style="list-style-type:disc">The custom signal handler function can perform any necessary cleanup or graceful shutdown operations before the process exits.</li></ul></li></ol><ol type="1" id="ff10da5b-8cf8-4516-a6d0-26ba2a953f08" class="numbered-list" start="3"><li><strong>Signal Delivery and Signal Handler Execution</strong>:<ul id="b8842ecf-dc39-4b8f-9395-216848533f5b" class="bulleted-list"><li style="list-style-type:disc">When the <code>SIGINT</code> signal is delivered to the process, the operating system suspends the current execution of the process and transfers control to the specified signal handler function.</li></ul><ul id="956ec43a-9ab1-4473-b951-69793a14616e" class="bulleted-list"><li style="list-style-type:disc">The signal handler function is executed in the context of the receiving process, allowing it to access the process&#x27;s resources and state.</li></ul></li></ol><ol type="1" id="2e47a92c-28a5-485c-af98-83426f44430f" class="numbered-list" start="4"><li><strong>Signal Handling Completion</strong>:<ul id="38cee9f0-481d-4bb8-9f12-0c321c55bb85" class="bulleted-list"><li style="list-style-type:disc">After the signal handler function completes its execution, the operating system resumes the normal execution of the process, either from the point where it was interrupted or from a different location, depending on the signal handling behavior specified by the process.</li></ul></li></ol><ol type="1" id="66791d6e-9c08-44bd-aab3-2a5f5e6b7612" class="numbered-list" start="5"><li><strong>Process Termination</strong>:<ul id="dfe4fff3-6502-4f1e-9157-b5e06733e88a" class="bulleted-list"><li style="list-style-type:disc">If the process does not have a custom signal handler for <code>SIGINT</code>, or if the signal handler does not explicitly request the process to continue running, the operating system will terminate the process.</li></ul><ul id="a94842ab-a217-4370-bee2-5832bd7e0b55" class="bulleted-list"><li style="list-style-type:disc">The process may also explicitly call the <code>exit()</code> system call within the signal handler to initiate the termination of the process.</li></ul></li></ol></details></li></ul><ul id="aff72e99-60ab-4070-9e1c-f476c635bb25" class="toggle"><li><details open=""><summary>signals and interrupts</summary><p id="1fb81ddb-87e6-4837-9fa7-64bee3760584" class="">Interrupts:</p><ul id="7964c4fd-8108-4b8f-abec-14d12a746851" class="bulleted-list"><li style="list-style-type:disc">Interrupts are hardware-generated events that temporarily suspend the normal flow of execution in a computer system.</li></ul><ul id="f2723073-775f-4d43-b619-e4104a7c64e0" class="bulleted-list"><li style="list-style-type:disc">Interrupts are triggered by external hardware devices or by internal system events, such as timer ticks, hardware errors, or I/O operations.</li></ul><ul id="e3373982-f27e-40fc-8c56-deec0eb29c76" class="bulleted-list"><li style="list-style-type:disc">Interrupts are handled by the processor&#x27;s interrupt handling mechanism, which saves the current state of the processor, transfers control to a specific interrupt service routine (ISR), and then restores the original state when the ISR has completed.</li></ul><ul id="33bb4ee0-34cb-4610-8ff9-8a59f94eb8b9" class="bulleted-list"><li style="list-style-type:disc">Interrupts are designed to be low-latency and time-critical, allowing the system to respond quickly to hardware events.</li></ul><p id="793f0226-0baa-4508-b0fb-2e9aa7fce187" class="">Signals:</p><ul id="2be56c78-d9a9-465b-ac19-8b08c8e1eafe" class="bulleted-list"><li style="list-style-type:disc">Signals are software-generated events that notify a process about an exceptional condition or an external event.</li></ul><ul id="4812256e-33ad-4d72-bc81-2b42c9655f9a" class="bulleted-list"><li style="list-style-type:disc">Signals are generated by the operating system or by other processes, and can be sent to a specific process or to all processes in a process group.</li></ul><ul id="35ec79e5-4bd8-459c-885f-78a866a05aa8" class="bulleted-list"><li style="list-style-type:disc">Signals are handled by the operating system&#x27;s signal handling mechanism, which allows the process to specify a signal handler function to be executed when a signal is received.</li></ul><ul id="7895f030-5142-4027-925c-44d8651ec3c1" class="bulleted-list"><li style="list-style-type:disc">Signals are designed to be more flexible and less time-critical than interrupts, allowing processes to perform more complex operations in response to the signal.</li></ul></details></li></ul><ul id="24bd5a9f-1c08-45ef-b6c8-178f882b910e" class="toggle"><li><details open=""><summary>running processes in background using &amp;</summary><p id="8c3a9956-c573-4242-901a-d563636bb374" class="">This is a process of creating a child process, detaching it from the terminal, and managing it through the shell&#x27;s job control system allows for the efficient execution of long-running or resource-intensive tasks in the background, while keeping the shell responsive and available for the user to enter new commands.</p><ol type="1" id="edf7d9a9-2fdb-4b12-b7a6-e2011d4b075e" class="numbered-list" start="1"><li><strong>Command Execution</strong>:<ul id="4df6a140-047c-4b5e-8f7f-57f3716a9f7b" class="bulleted-list"><li style="list-style-type:disc">When the user enters a command with the <code>&amp;</code> operator, the shell parses the command and identifies that it should be run in the background.</li></ul></li></ol><ol type="1" id="0ad30d32-9f93-4d9d-a111-c25efc1138a7" class="numbered-list" start="2"><li><strong>Process Creation</strong>:<ul id="3b5f1ef3-17b5-420a-a85e-a1e39fc99905" class="bulleted-list"><li style="list-style-type:disc">The shell uses the <code>fork()</code> system call to create a new child process that will execute the command.</li></ul><ul id="8392241f-fbe6-4d10-ba92-ee42f0f7b679" class="bulleted-list"><li style="list-style-type:disc">The child process inherits the environment and state of the parent shell process.</li></ul></li></ol><ol type="1" id="2103c009-c666-442f-a665-a477d433535f" class="numbered-list" start="3"><li><strong>Detachment from Terminal</strong>:<ul id="6295ed57-3904-4b5f-8530-20d4a4640aa9" class="bulleted-list"><li style="list-style-type:disc">After the child process is created, the shell uses the <code>setsid()</code> system call to create a new session and become the process group leader for the child process.</li></ul><ul id="7699f4da-a555-461f-9aa0-26c8ef0306f3" class="bulleted-list"><li style="list-style-type:disc">This step detaches the child process from the controlling terminal, effectively &quot;backgrounding&quot; it.</li></ul></li></ol><ol type="1" id="bdd47714-92c4-4450-829c-72de71356fec" class="numbered-list" start="4"><li><strong>Signal Handling</strong>:<ul id="52222f27-5342-43a0-a8c2-56102c9a8b06" class="bulleted-list"><li style="list-style-type:disc">The child process inherits the signal handlers and signal mask of the parent shell process.</li></ul><ul id="b88df76f-830d-4134-9742-c479ebb50b56" class="bulleted-list"><li style="list-style-type:disc">However, the child process typically resets the signal handlers to their default behavior, ignoring signals like <code>SIGINT</code> (Ctrl+C) that would normally terminate the process.</li></ul></li></ol><ol type="1" id="bf324c4b-b1ba-4873-b47a-60b7c1370816" class="numbered-list" start="5"><li><strong>Output Redirection</strong>:<ul id="0f44f805-206f-4db2-b2dc-046389180f32" class="bulleted-list"><li style="list-style-type:disc">By default, the output (stdout and stderr) of the background process is still connected to the terminal, which can cause issues if the process generates a lot of output.</li></ul><ul id="f57688a8-c299-4867-b9ec-5d1c26c72bac" class="bulleted-list"><li style="list-style-type:disc">To avoid this, the shell may redirect the output of the background process to a file or to <code>/dev/null</code> to discard it.</li></ul></li></ol><ol type="1" id="3b7834b3-8140-467e-8b97-a875cb9163dc" class="numbered-list" start="6"><li><strong>Process Monitoring</strong>:<ul id="1d19ccff-8766-4087-94ee-7326450ef211" class="bulleted-list"><li style="list-style-type:disc">The shell adds the child process to its internal job control system, which allows the user to manage the background process using commands like <code>jobs</code>, <code>fg</code>, and <code>bg</code>.</li></ul></li></ol><ol type="1" id="332be296-7965-4eac-9d43-be90861bf59d" class="numbered-list" start="7"><li><strong>Return to Shell Prompt</strong>:<ul id="1ab104ee-ac51-45c2-a18d-9d76db5408d7" class="bulleted-list"><li style="list-style-type:disc">After the child process is successfully created and detached, the shell returns control to the user, displaying the shell prompt and allowing the user to enter new commands.</li></ul></li></ol><ol type="1" id="01dfc313-b814-4247-85c5-abfcd31db048" class="numbered-list" start="8"><li><strong>Background Process Execution</strong>:<ul id="73cab11d-79bc-44a9-9a46-545e00c01bb9" class="bulleted-list"><li style="list-style-type:disc">The child process continues to execute in the background, independent of the shell that launched it.</li></ul><ul id="ebbd5e48-8871-42c0-b9c8-5d17cc40608d" class="bulleted-list"><li style="list-style-type:disc">If the background process receives a signal like <code>SIGINT</code>, it will ignore the signal, as its signal handlers have been reset to the default behavior.</li></ul><ul id="e7991be3-a89a-484b-952f-ed9c6663a584" class="bulleted-list"><li style="list-style-type:disc">The background process will continue to run until it completes, encounters an error, or is explicitly terminated by the user or another process.</li></ul></li></ol></details></li></ul></div></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">setsid</summary></details><details open=""><summary style="font-weight:600;font-size:1.25em;line-height:1.3;margin:0">exec</summary></details></details></li></ul></div></details><hr id="a48bbd23-9702-4d10-a620-2f79b03b2fdd"/><ul id="2d055a24-046f-446a-9927-9499be928d63" class="toggle"><li><details open=""><summary>file descriptor(fd) and fd table</summary><p id="c5d88db6-64aa-4c25-8d20-81c12a62c843" class="">In simple words, when you open a file, the operating system creates an entry to represent that file and store the information about that opened file. So if there are 100 files opened in your OS then there will be 100 entries in OS (somewhere in kernel). These entries are represented by integers like (...100, 101, 102....). This entry number is the file descriptor. So it is just an integer number that uniquely represents an opened file for the process. If your process opens 10 files then your Process table will have 10 entries for file descriptors.</p><p id="cbc7890d-89b6-4118-9a77-1155b3c0d36c" class="">Similarly, when you open a network socket, it is also represented by an integer and it is called Socket Descriptor.</p><hr id="fb02930f-cc5a-4cf9-b317-bfb9d6385561"/><p id="17a4f7dd-1d1b-41e6-8ef0-6cacc8e27e12" class="">The file descriptor table is an important concept related to how operating systems manage open files for processes. Here&#x27;s a concise explanation of the file descriptor table:</p><ol type="1" id="26c5ed3c-b05f-4e3c-aa31-ccdc519d286d" class="numbered-list" start="1"><li>Definition: It&#x27;s a data structure maintained by the operating system for each process, mapping file descriptors to file table entries.</li></ol><ol type="1" id="c485287e-d500-48db-a3a4-3ca72d7abc78" class="numbered-list" start="2"><li>Structure:<ul id="dfa20139-737a-4d45-a7c0-b20f17d3350d" class="bulleted-list"><li style="list-style-type:disc">An array of pointers</li></ul><ul id="958b2ac9-d52f-4e6d-8620-7cc03eb8ca0b" class="bulleted-list"><li style="list-style-type:disc">Index is the file descriptor number</li></ul><ul id="6445650f-d4a6-484d-8de2-b1593e4e3213" class="bulleted-list"><li style="list-style-type:disc">Each entry points to a file table entry</li></ul></li></ol><ol type="1" id="c16fdb1f-8751-46e0-8929-5ec0e19b918b" class="numbered-list" start="3"><li>File table entry contents:<ul id="8c00bf58-2489-4537-a0f7-73a41037831a" class="bulleted-list"><li style="list-style-type:disc">File offset</li></ul><ul id="b0089eb9-5ce8-49a6-b666-ed6d262716d0" class="bulleted-list"><li style="list-style-type:disc">Access mode (read, write, etc.)</li></ul><ul id="bf2bd561-1f9c-4917-88ab-fd6cb6fa53db" class="bulleted-list"><li style="list-style-type:disc">Pointer to inode (contains file metadata)</li></ul></li></ol><ol type="1" id="2a933248-b418-468a-b7c2-2a598ae3f768" class="numbered-list" start="4"><li>Purpose:<ul id="05938347-aa4b-4b4e-a0f2-c4babc27ba9e" class="bulleted-list"><li style="list-style-type:disc">Keeps track of all open files for a process</li></ul><ul id="a1092454-a3f0-4939-b850-d4cc82f097bb" class="bulleted-list"><li style="list-style-type:disc">Enables efficient file access and management</li></ul></li></ol></details></li></ul><hr id="63c0a099-48f1-4895-ba0d-79dc0e8e50e4"/><h3 id="8e67213b-e8c1-4942-9e2e-6d7f31b704c2" class="">Process Management</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="7aea4e66-44fc-4931-8177-da4ff25b0f9d"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="3714a6c5-0bdd-4011-9240-d362bc7d3e95" class="">Program under execution is called process</p></div></figure><ul id="f5c2360e-f202-4d3b-94a4-d50612f01dfd" class="toggle"><li><details open=""><summary>Explain when you click a program.c how it turns into a process</summary><h3 id="5f062e14-fe69-4c86-961d-e842e5f0b05b" class="">a. <strong>Load the Program &amp; Static Data into Memory:</strong></h3><ul id="f50e994e-19f8-40e5-bcff-4ebf68cc193a" class="bulleted-list"><li style="list-style-type:disc">The operating system loads the program&#x27;s executable code and its associated static data (like global variables and constants) into the process&#x27;s memory space. This typically includes the code segment and data segment.</li></ul><h3 id="72265387-c720-4ff4-a5ff-1d2456fdb69c" class="">b. <strong>Allocate Runtime Stack:</strong></h3><ul id="3db0dfb4-c5fe-4a5f-ad09-b795847e7b71" class="bulleted-list"><li style="list-style-type:disc">The OS allocates memory for the process&#x27;s runtime stack, which is used to manage function calls, local variables, and return addresses. The stack grows and shrinks dynamically as functions are called and return.</li></ul><h3 id="207eb6fe-5459-4eb9-8424-44e67e171251" class="">c. <strong>Heap Memory Allocation:</strong></h3><ul id="0766b008-043c-4de4-8c65-8e7266d151d3" class="bulleted-list"><li style="list-style-type:disc">The OS sets aside memory for the heap, a region used for dynamic memory allocation during the process&#x27;s execution. The heap allows the process to allocate and deallocate memory as needed at runtime (e.g., with <code>malloc</code> in C).</li></ul><h3 id="263e4585-8e4e-4639-b120-564808b1c5a2" class="">d. <strong>IO Tasks:</strong></h3><ul id="bb8145ab-2fe6-4a29-b014-9558cd19c312" class="bulleted-list"><li style="list-style-type:disc">The OS prepares the process for input/output operations by setting up file descriptors (UNIX/Linux) or handles (Windows) for files, devices, and other IO resources. This ensures the process can read and write data as needed.</li></ul><ul id="30365510-e48c-47c2-99f8-237ecbc8ead5" class="bulleted-list"><li style="list-style-type:disc">For the IO os needs to setup handlers for handling. So handlers are setuped</li></ul><h3 id="867120ab-73e8-42b2-bf12-a8dac0d48038" class="">e. <strong>OS Handoffs Control to </strong><code><strong>main()</strong></code><strong>:</strong></h3><ul id="3b3819a2-4473-4f23-a4b6-b7330181a8a9" class="bulleted-list"><li style="list-style-type:disc">After setting up the process environment, the OS transfers control to the process by invoking its entry point, typically the <code>main()</code> function. The process then begins execution from this point, following the program&#x27;s logic.</li></ul><ul id="b2a8db84-c5f7-424a-8c37-ec6777a84085" class="bulleted-list"><li style="list-style-type:disc">Also the status is returned at the end of the main determines the termination status of the process</li></ul><p id="a1757956-e40c-42a4-9f63-6ea05b743cfd" class="">
</p></details></li></ul><ul id="f2c08cde-5f8d-4d92-8d51-dcf61220b935" class="toggle"><li><details open=""><summary>How process is created → full</summary><h3 id="285c5c21-101c-4f1b-99d1-070f6a6b7d86" class="">1. <strong>Forking (UNIX/Linux) or Creating a Process (Windows):</strong></h3><ul id="85915159-8d7a-4bbb-98ae-1b1b14545874" class="bulleted-list"><li style="list-style-type:disc"><strong>UNIX/Linux (Forking):</strong> The <code>fork()</code> system call is used to create a new process. This call creates a child process that is a duplicate of the parent process. The child process gets its own unique Process ID (PID) and a copy of the parent&#x27;s memory space.</li></ul><ul id="78e67944-75ec-4ea9-a810-465f00ae0825" class="bulleted-list"><li style="list-style-type:disc"><strong>Windows (CreateProcess):</strong> The <code>CreateProcess()</code> function is used, which creates a new process and its primary thread. It also loads the specified executable file into the new process&#x27;s address space.</li></ul><h3 id="17f5e99c-bc5b-424d-adf6-bf6afcd0f0c6" class="">2. <strong>Loading the Program:</strong></h3><ul id="6994ec90-355f-4497-828c-3e5abc29c627" class="bulleted-list"><li style="list-style-type:disc">After forking or creating the process, the OS loads the program (binary or executable file) that the process will run into the process&#x27;s address space. This involves loading the code, initializing the stack, heap, and data sections.</li></ul><h3 id="9b30b141-9794-42d0-a34f-71f316f1002b" class="">3. <strong>Setting Up the Execution Environment:</strong></h3><ul id="38f56cf6-8e17-4fef-a0c4-b6c84124255f" class="bulleted-list"><li style="list-style-type:disc"><strong>Memory Management:</strong> The OS allocates memory for the process&#x27;s stack, heap, and data segments. It also sets up page tables if using virtual memory.</li></ul><ul id="99d29f3e-25fd-43a4-9fd5-55c9fe8942bb" class="bulleted-list"><li style="list-style-type:disc"><strong>File Descriptors or Handles:</strong> The child process inherits file descriptors (UNIX/Linux) or handles (Windows) from the parent. These are used for input/output operations.</li></ul><ul id="e4082bc2-9329-41cc-8549-6fdd17f47701" class="bulleted-list"><li style="list-style-type:disc"><strong>Process Control Block (PCB):</strong> The OS creates a PCB for the process, which stores important information such as the process ID, process state, CPU registers, memory pointers, scheduling information, and more.</li></ul><h3 id="84022595-6002-411e-9dc0-583eecdd81d4" class="">4. <strong>Assigning a Process ID:</strong></h3><ul id="c275d2df-be86-4cd2-8802-0eafffc1a0f4" class="bulleted-list"><li style="list-style-type:disc">The OS assigns a unique Process ID (PID) to the new process. This PID is used to manage and identify the process.</li></ul><h3 id="0f5d9e68-8765-4326-bfed-6ccedd575d7b" class="">5. <strong>Scheduling the Process:</strong></h3><ul id="3a456048-d1a5-448e-9436-738e049fb1a0" class="bulleted-list"><li style="list-style-type:disc">The OS scheduler places the new process in the ready queue. Depending on the scheduling algorithm, the process will be selected for execution on the CPU.</li></ul><h3 id="01ba8a1b-317a-4b44-97ee-2a00c3dfce7a" class="">6. <strong>Execution:</strong></h3><ul id="fb0c03e5-7216-433d-9071-e32e21381a59" class="bulleted-list"><li style="list-style-type:disc">The process is now ready to execute. The CPU context is set up, and the process begins execution from the entry point of the loaded program.</li></ul><h3 id="c94615d6-762d-4e02-824a-22ae7933daca" class="">7. <strong>Resource Allocation:</strong></h3><ul id="a33ead6d-480f-4223-8e61-ddb24d4c6295" class="bulleted-list"><li style="list-style-type:disc">The OS allocates necessary resources such as CPU time, memory, and I/O devices to the process as it executes.</li></ul><h3 id="5d63164e-5dcf-45f2-8919-2bc3300fa2f1" class="">8. <strong>Process Execution and Termination:</strong></h3><ul id="1eb122d6-0347-4932-b4e6-bad416564f3b" class="bulleted-list"><li style="list-style-type:disc">The process executes its instructions. Upon completion, the process exits using system calls like <code>exit()</code> (UNIX/Linux) or <code>ExitProcess()</code> (Windows). The OS then cleans up the resources, updates the PCB, and may notify the parent process of the child&#x27;s termination.</li></ul></details></li></ul><ul id="2f68cd0e-1d50-4168-9bbf-8fbe260e0f86" class="toggle"><li><details open=""><summary>How process looks inside a memory architecture of a process</summary><figure id="b2dab71a-a676-4faa-ae07-c8510d79f4d4" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/image%201.png"><img style="width:360px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/image%201.png"/></a></figure><h3 id="ebb23b3f-6622-4c19-8127-0a5f300658b2" class=""><strong>1. Text Segment (Code Segment):</strong></h3><ul id="f9acd2fe-2844-4863-9f66-97fedf9c7021" class="bulleted-list"><li style="list-style-type:disc"><strong>Location:</strong> At the lower end of the memory space.</li></ul><ul id="f8e966be-7b9b-4ba5-ac81-33d93c3f41b5" class="bulleted-list"><li style="list-style-type:disc"><strong>Content:</strong> This segment contains the executable instructions of the program (the compiled code). It&#x27;s usually read-only to prevent accidental modification of the code.</li></ul><h3 id="2a2f6a42-6562-4d8c-aea3-00b118deabee" class="">2. <strong>Data Segment:</strong></h3><p id="1146f5dc-5a22-4914-9f96-936da3a93a4b" class=""><strong>Data Section</strong> segment of memory contains the global and static variables that are initialized by the programmer prior to the execution of a program. This segment is not read-only, as the value of the variables can be changed at the runtime.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7c7f053c-9d2b-45da-9848-e0c5a300bf9f" class="code"><code class="language-YAML">#include&lt;stdio.h&gt;
int b;//will be stored in data section
int main(){
   static int a; //will be stored in data section
   return;
}</code></pre><p id="8010eb73-3f5c-49b2-8ac2-3602871e99d6" class="">As a whole both form the data segment</p><ul id="c7b5756d-883b-41d9-8bcf-8519683314bf" class="bulleted-list"><li style="list-style-type:disc"><strong>Static Data:</strong><ul id="b8c09010-ceee-4edd-99b7-20b9b05b19c9" class="bulleted-list"><li style="list-style-type:circle"><strong>Content:</strong> Stores global and static variables that are initialized before the process starts.</li></ul><ul id="c2a399ab-9f40-4e16-85a6-b04e1fcc8554" class="bulleted-list"><li style="list-style-type:circle"><strong>Example:</strong> Variables declared as <code>int x = 5;</code> in C.</li></ul></li></ul><ul id="2836fd40-393a-4c15-bcd4-6dcc906c0cbc" class="bulleted-list"><li style="list-style-type:disc"><strong>Uninitialized Data (BSS - Block Started by Symbol):</strong><ul id="749d596f-2e00-4d81-9929-27ba8202fe7f" class="bulleted-list"><li style="list-style-type:circle"><strong>Content:</strong> Contains global and static variables that are uninitialized or set to zero at the start.</li></ul><ul id="2c2cb527-a567-41e7-b00f-838e2064229a" class="bulleted-list"><li style="list-style-type:circle"><strong>Example:</strong> Variables declared as <code>int y;</code> in C without an initial value.</li></ul></li></ul><h3 id="2a9dc9b9-77b5-4742-9e7b-ccd01ebaf9c6" class="">3. Heap Segment</h3><ul id="8db825ad-e215-486b-bbe1-7f31388ca5a7" class="bulleted-list"><li style="list-style-type:disc"><strong>Location:</strong> Grows upward, starting after the data segment.</li></ul><ul id="c800cf51-fc24-4428-a3a7-94686155172c" class="bulleted-list"><li style="list-style-type:disc"><strong>Content:</strong> This area is used for dynamic memory allocation during runtime (e.g., memory allocated using <code>malloc</code> in C or <code>new</code> in C++). The heap size can increase or decrease based on memory allocation and deallocation.</li></ul><h3 id="fdde44f6-ee59-4da1-a9b5-5fb78a83cd6a" class=""><strong>4. Stack:</strong></h3><ul id="960d55d0-5590-466a-bd66-4752200bc920" class="bulleted-list"><li style="list-style-type:disc"><strong>Location:</strong> Grows downward, starting from the upper end of the memory space.</li></ul><ul id="6cfd99d0-d8b8-4a64-8cd6-946f130ddef8" class="bulleted-list"><li style="list-style-type:disc"><strong>Content:</strong> The stack stores function call frames (activation records), including local variables, function arguments, return addresses, and control information. <strong>Each time a function is called, a new stack frame is pushed onto the stack, and it&#x27;s popped when the function returns.</strong></li></ul><hr id="3b8cda9f-99e1-4713-9112-3bb8fb8f8832"/><h3 id="2665a928-77a5-402a-a59f-e007640475fe" class="">Where environment variables and command line arguments are stored</h3><ul id="4d0d5d44-31c9-459f-979c-7be730faa286" class="bulleted-list"><li style="list-style-type:disc"><strong>Location:</strong> Typically stored between the stack and heap or in the initial part of the stack.</li></ul><ul id="6bb2416b-b866-43e8-b891-253caea1c8af" class="bulleted-list"><li style="list-style-type:disc"><strong>Content:</strong> Includes environment variables, command-line arguments, and other configuration details passed to the process when it starts.</li></ul><p id="da1527eb-840d-4ccf-b8e5-936a59695b49" class="">
</p></details></li></ul><ul id="fbdc72d5-b76d-4e6f-96a5-fe5ca4f2480d" class="toggle"><li><details open=""><summary>How does Stack Overflow error occurs</summary><p id="d8fbccd3-86d0-468f-928b-95187f97eba0" class="">If stack boundary meets the heap boundary we will get stack overflow error</p><ul id="be38600e-7669-440f-a7c2-ecb93702f862" class="bulleted-list"><li style="list-style-type:disc"><strong>Cause:</strong> A stack overflow occurs when a program uses more stack space than is available. The stack typically has a fixed size, and it grows downward in memory. If a program recursively calls functions too deeply, allocates too much space on the stack (e.g., with large local arrays), or otherwise exceeds the stack limit, it can cause the stack to grow into an adjacent memory region (like the heap) or to run out of allocated stack space entirely.</li></ul><ul id="7c5b814b-af87-446a-ad5f-f1f5856f50c8" class="bulleted-list"><li style="list-style-type:disc"><strong>Result:</strong> The program typically crashes, and a &quot;stack overflow&quot; error is generated. In some operating systems, this may result in a segmentation fault or access violation.</li></ul></details></li></ul><ul id="1720bd7e-cb93-442b-9016-2dbb26a30369" class="toggle"><li><details open=""><summary>How does Out of memory error occurs</summary><ul id="c7ffb932-df5f-48d8-8849-3fc62d4a87bd" class="bulleted-list"><li style="list-style-type:disc"><strong>Cause:</strong> An out-of-memory error occurs when a process requests more memory than the system can provide, either due to overall system memory limits or because the process&#x27;s address space is exhausted. This can happen if:<ul id="d1446ee0-28c9-4aef-b5fe-b9dc84446267" class="bulleted-list"><li style="list-style-type:circle">The heap grows too large, consuming all available memory.</li></ul><ul id="6c2481eb-b872-4f7e-a5a8-b32d9b068685" class="bulleted-list"><li style="list-style-type:circle">The system runs out of physical memory (RAM) and cannot allocate more, even though the process may still have virtual address space available.</li></ul><ul id="a0ad9261-0772-4640-80d9-e149fb531ef0" class="bulleted-list"><li style="list-style-type:circle">A memory allocation request (e.g., <code>malloc</code> in C or <code>new</code> in C++) fails because there&#x27;s no more free memory to satisfy the request.</li></ul></li></ul><ul id="12802f77-f476-4ebc-a9d1-34b2fb22e6df" class="bulleted-list"><li style="list-style-type:disc"><strong>Result:</strong> The process may crash, or an error is returned by the memory allocation function, such as <code>NULL</code> in C, indicating that the allocation failed. In managed environments like Java, an <code>OutOfMemoryError</code> is thrown.</li></ul></details></li></ul><ul id="835fb844-b739-4700-b029-513ae7f413f1" class="toggle"><li><details open=""><summary>Difference between stack overflow and out of memory</summary><ul id="c585f132-05b7-4bf0-b17d-f265f1762631" class="bulleted-list"><li style="list-style-type:disc">Cause:<ul id="602b495f-7753-417f-9fc6-5fb5cf0bcfb0" class="bulleted-list"><li style="list-style-type:circle">Stack overflow: Occurs when the call stack in a program exceeds its maximum size, typically due to excessive recursion or very deep function call nesting.</li></ul><ul id="40e71b1a-1192-4945-a278-652eb64187f5" class="bulleted-list"><li style="list-style-type:circle">Out of memory: Happens when a program requests more memory than is available in the system&#x27;s RAM and virtual memory.</li></ul></li></ul><ul id="20527510-010f-4182-b09d-c0fbdf7a11b5" class="bulleted-list"><li style="list-style-type:disc">Memory region affected:<ul id="61bf5bb9-26e1-4335-9abd-2a3b785a9736" class="bulleted-list"><li style="list-style-type:circle">Stack overflow: Affects the stack memory, which is used for storing local variables and function call information.</li></ul><ul id="ea64f26c-2ec4-4f1c-ada3-fc4a67909f03" class="bulleted-list"><li style="list-style-type:circle">Out of memory: Usually affects the heap memory, which is used for dynamic memory allocation.</li></ul></li></ul><ul id="4384bbc1-f584-4154-af2c-ff7832e5e7c3" class="bulleted-list"><li style="list-style-type:disc">Typical scenarios:<ul id="3230688f-804d-465e-b2d0-fda7922a6fdc" class="bulleted-list"><li style="list-style-type:circle">Stack overflow: Often seen in recursive functions without proper termination conditions or extremely nested function calls.</li></ul><ul id="a297512f-fb7f-498f-9160-6f578051fb98" class="bulleted-list"><li style="list-style-type:circle">Out of memory: Commonly occurs when allocating large objects, dealing with big datasets, or memory leaks.</li></ul></li></ul><ul id="b62f5c0d-088e-43c3-9671-78d6d03e7be6" class="bulleted-list"><li style="list-style-type:disc">Prevention:<ul id="6a39e51d-84b0-4a20-9481-22f25714a8a0" class="bulleted-list"><li style="list-style-type:circle">Stack overflow: Can be prevented by optimizing recursive algorithms, using iteration instead of recursion, or increasing the stack size if possible.</li></ul><ul id="c975c9c9-f20c-4957-b2c1-c91073f9354a" class="bulleted-list"><li style="list-style-type:circle">Out of memory: Addressed by optimizing memory usage, implementing proper memory management, or increasing available system memory.</li></ul></li></ul><ul id="b3b80c62-fa63-45c0-86fb-3663e3104b9c" class="bulleted-list"><li style="list-style-type:disc">Error messages:<ul id="d7ec502d-6acd-4fbe-8765-e9b33e10719c" class="bulleted-list"><li style="list-style-type:circle">Stack overflow: Often reported as &quot;StackOverflowError&quot; or similar.</li></ul><ul id="0dac2a86-a71f-40a5-ba3a-8eaf1e43eac6" class="bulleted-list"><li style="list-style-type:circle">Out of memory: Typically shown as &quot;OutOfMemoryError&quot; or &quot;Insufficient memory&quot; messages.</li></ul></li></ul></details></li></ul><ul id="d0cb8997-13fa-4eca-886c-d74ef954e503" class="toggle"><li><details open=""><summary>Context or attributes or characteristic of a process</summary><ul id="fef38828-64c3-4878-8c96-a0276329c4ac" class="bulleted-list"><li style="list-style-type:disc"><strong>Process Id:</strong> A unique identifier assigned by the operating system.</li></ul><ul id="c336ac79-5819-4d2d-be5b-3b35d0693d6c" class="bulleted-list"><li style="list-style-type:disc"><strong>Process State:</strong> Can be ready, running, etc.</li></ul><ul id="374991e8-8a1e-40d9-9fa1-163339d86b2c" class="bulleted-list"><li style="list-style-type:disc"><strong>CPU Registers:</strong> Like the Program Counter (CPU registers must be saved and restored when a process is swapped in and out of the CPU)</li></ul><ul id="1ebaa7c4-0b82-415d-a613-97fd76e4e8ec" class="bulleted-list"><li style="list-style-type:disc"><strong>Accounts Information:</strong> Amount of CPU used for process execution, time limits, execution ID, etc</li></ul><ul id="ac37a169-4091-4a94-8f51-6a5f45f3151f" class="bulleted-list"><li style="list-style-type:disc"><strong>I/O Status Information:</strong> For example, devices allocated to the process, open files, etc</li></ul><ul id="de99a435-7332-4ba0-8719-696084b1e9ed" class="bulleted-list"><li style="list-style-type:disc"><strong>CPU Scheduling Information:</strong> For example, Priority (Different processes may have different priorities, for example, a shorter process assigned high priority in the shortest job first scheduling)</li></ul><p id="c3185df4-c442-4020-a4f8-05b13945f80e" class="">
</p></details></li></ul><ul id="ad0ed6c6-6c80-4527-ab05-3a517db425ac" class="toggle"><li><details open=""><summary>Process Control Block</summary><p id="9e281526-5774-477b-8505-5d955384d175" class="">Every process has its own <strong><a href="http://en.wikipedia.org/wiki/Process_control_block">process control block</a></strong>(PCB), i.e. each process will have a unique PCB. All of the above attributes are part of the PCB. It is a datastructure</p><p id="d9cb1e94-76f8-4962-889c-55b42f1c0fff" class="">OS recognizes a process by its PCB</p><p id="c4d0afac-af10-478d-84f5-66315c50a108" class="">Structure</p><figure id="fed36fc8-f7ae-4925-8c80-202d9b13f1ef" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/image%202.png"><img style="width:199px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/image%202.png"/></a></figure><ul id="ff0451f3-6bf8-42ad-ad65-283500762d52" class="bulleted-list"><li style="list-style-type:disc"><strong>Process ID (PID):</strong> Unique identifier for the process, used to distinguish it from other processes.</li></ul><ul id="4ed7d056-6420-4201-857a-405704ef3933" class="bulleted-list"><li style="list-style-type:disc"><strong>Process State:</strong> Current state of the process (e.g., running, waiting, blocked, terminated).</li></ul><ul id="d906ed99-2deb-4318-b57a-7da10a521a70" class="bulleted-list"><li style="list-style-type:disc"><strong>Program Counter (PC):</strong> Address of the next instruction to be executed by the process.</li></ul><ul id="300f64ab-1691-4c07-aafa-9beb9e8a5524" class="bulleted-list"><li style="list-style-type:disc"><strong>CPU Registers:</strong> Set of registers that store the current working variables and state of the CPU for the process.</li></ul><ul id="cbfbb839-17f1-4a13-a808-1ac95089d076" class="bulleted-list"><li style="list-style-type:disc"><strong>Process Priority:</strong> Priority level of the process, which the scheduler uses to decide the order of execution.</li></ul><ul id="3720d8cd-5eff-4783-b844-365ac4fc9532" class="bulleted-list"><li style="list-style-type:disc"><strong>Process Context:</strong> Snapshot of the process’s CPU state (registers, PC, etc.) that allows the process to be resumed correctly after being interrupted.</li></ul><ul id="a35c8958-08bf-4f12-9786-b66bfbb50e21" class="bulleted-list"><li style="list-style-type:disc"><strong>Pointer to Next PCB:</strong> Link to the next PCB in the list, used in managing processes within the scheduling queues.</li></ul><ul id="044edbf7-a4c9-442c-9898-bad0381735ad" class="bulleted-list"><li style="list-style-type:disc"><strong>List of Open Files:</strong> Tracks all the files the process currently has open, including file descriptors and access permissions.</li></ul><ul id="5a83b988-e3bb-4c4e-a367-21688ab7033b" class="bulleted-list"><li style="list-style-type:disc"><strong>List of Open Devices:</strong> Manages the I/O devices currently in use by the process, including device identifiers and control information.</li></ul></details></li></ul><ul id="b10796d5-fd5a-47bf-986b-992a240f52f4" class="toggle"><li><details open=""><summary>Process states and Process lifecycle</summary><figure id="2f392d63-b82b-4b5a-9b02-7ac30e5fc80b" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/image%203.png"><img style="width:656px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/image%203.png"/></a></figure><ul id="7090f314-0739-4bb5-9950-962ef0abba13" class="bulleted-list"><li style="list-style-type:disc"><strong>Creation:</strong> The process starts in the <strong>New</strong> state.</li></ul><ul id="1da1f5d7-44b3-44f7-a088-9c945c765bb4" class="bulleted-list"><li style="list-style-type:disc"><strong>Ready to Run:</strong> Once initialized, it moves to the <strong>Ready</strong> state, waiting for CPU time.</li></ul><ul id="c8bd97b3-1372-4935-b616-4a54c799049a" class="bulleted-list"><li style="list-style-type:disc"><strong>Execution:</strong> When scheduled by the OS, it moves to the <strong>Running</strong> state.</li></ul><ul id="f956c80f-31bc-42ec-926e-d60407c40696" class="bulleted-list"><li style="list-style-type:disc"><strong>Waiting:</strong> If it needs to wait for resources or an event, it transitions to the <strong>Waiting</strong> state.</li></ul><ul id="eaf59168-d4be-4049-9504-cb004fca9af1" class="bulleted-list"><li style="list-style-type:disc"><strong>Completion:</strong> After finishing execution, it enters the <strong>Terminated</strong> state.</li></ul><ul id="f04a42cf-3e02-44f3-8724-e9428236d427" class="bulleted-list"><li style="list-style-type:disc"><strong>Suspension:</strong> If the system needs to free up memory, a <strong>Ready</strong> or <strong>Waiting</strong> process can be moved to <strong>Suspended</strong> states, to be resumed later.</li></ul><h3 id="88146f76-d030-4de1-81e9-7af045e5e418" class="">States</h3><h3 id="aafe5ef2-713d-4cae-9789-9dd4af46867d" class=""><strong>1. New:</strong></h3><ul id="adafcee7-e55c-4dd7-bb5c-7edb77bd89c1" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> The process is being created and initialized but has not yet started executing.</li></ul><h3 id="870a2010-b0b1-4732-8b2b-45821fbdc9ce" class=""><strong>2. Ready:</strong></h3><ul id="4b6f5344-9624-40e5-9c59-2d6e83d7f799" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> The process is loaded into memory and is waiting to be assigned to a CPU for execution.</li></ul><h3 id="c8c8affd-39b3-4482-8e75-659bc74d8a92" class=""><strong>3. Running:</strong></h3><ul id="7e0d10ce-2635-49de-8b07-3a0552bb3902" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> The process is currently being executed by the CPU.</li></ul><h3 id="6b382e80-245d-48a9-9126-eb116d5fda1d" class=""><strong>4. Waiting (Blocked):</strong></h3><ul id="4f6ecc73-d2d2-450a-b24b-448df16676c8" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> The process cannot continue executing until some external event occurs (e.g., I/O completion).</li></ul><h3 id="9166ba49-1eeb-4da3-8ca6-2daedb8afa71" class=""><strong>5. Terminated:</strong></h3><ul id="d2b49343-e1a9-485a-8b4b-64bc070944c8" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> The process has completed its execution or has been explicitly killed and is waiting to be removed from the process table.</li></ul><h3 id="52a8a281-6b61-44b7-892b-94e586886f07" class=""><strong>6. Suspended (Ready Suspended):</strong></h3><ul id="fe873892-4833-4bf6-8b4f-989f7761db07" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> The process is in secondary storage (e.g., swapped out to disk) and is waiting to be brought back into memory to continue execution.</li></ul><h3 id="e4dfb32c-280c-48a5-a76d-567f9d8a2530" class=""><strong>7. Suspended (Blocked Suspended):</strong></h3><ul id="e77f0f6f-7cd9-4e53-9df5-5d9e2359d56f" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> The process is both waiting for an event to occur and is swapped out of memory, awaiting reactivation.</li></ul><h3 id="0d34ceb2-e1cc-4fe7-ac82-0c714e2a3e1a" class=""></h3></details></li></ul><ul id="3c25970e-14ea-46a9-aa29-59c2be7bd712" class="toggle"><li><details open=""><summary>All Types of queue</summary><h3 id="1acaee26-4555-4a84-9b4d-7b757e2e1060" class=""><strong>1. Job Queue:</strong></h3><ul id="0470caad-4295-4034-8533-c81bfb24e663" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> Contains all processes that are in the <strong>New</strong> state, waiting to be admitted into the ready queue.</li></ul><ul id="f45ed895-edcd-4bd8-a7be-b08f7f91fe17" class="bulleted-list"><li style="list-style-type:disc"><strong>Purpose:</strong> Manages processes that have been submitted to the system but have not yet been scheduled for execution.</li></ul><h3 id="da7c5ef5-f891-4070-b465-bd87d57258ed" class=""><strong>2. CPU Queue:</strong></h3><ul id="50373bf1-4aa3-4584-8b4a-1b7a4a5b0e5b" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> A specialized queue that holds processes currently executing on the CPU.</li></ul><ul id="184a5b66-54d9-4890-b48e-8ee0c3994e27" class="bulleted-list"><li style="list-style-type:disc"><strong>Purpose:</strong> Ensures that the process is actively running and allows for process context switching when necessary.</li></ul><h3 id="3b4a9ad3-f61c-46de-bbea-b35d62dd3396" class=""><strong>2. Ready Queue:</strong></h3><ul id="d31de6e8-3b7f-473b-9511-5a04fd4ba357" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> Holds processes that are in the <strong>Ready</strong> state, waiting to be assigned CPU time for execution.</li></ul><ul id="a44569a9-2862-4dff-ad51-c2d5e8e491a8" class="bulleted-list"><li style="list-style-type:disc"><strong>Purpose:</strong> Ensures that the scheduler can efficiently select which process to run next based on scheduling policies.</li></ul><h3 id="23c79db7-1a67-42d2-a9b3-7d9c8b3f7036" class=""><strong>3. Waiting (Blocked) Queue:</strong></h3><ul id="aff89314-7928-4b92-bbd0-34fd61a51be3" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> Contains processes that are in the <strong>Waiting</strong> (or <strong>Blocked</strong>) state, waiting for some event or I/O operation to complete.</li></ul><ul id="d6d956e7-8d1c-4e14-926c-1215e7f0bee2" class="bulleted-list"><li style="list-style-type:disc"><strong>Purpose:</strong> Manages processes that cannot proceed until they receive the necessary resources or events.</li></ul><h3 id="4643561d-07c9-4c71-b94b-1687fed4c730" class=""><strong>4. I/O Queue:</strong></h3><ul id="8b26af0e-6d4f-4993-8c3b-58bec7f9c6b3" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> Maintains processes that are waiting for I/O operations to complete.</li></ul><ul id="399d3498-d6d7-4c52-8346-9cce9ffbf957" class="bulleted-list"><li style="list-style-type:disc"><strong>Purpose:</strong> Manages processes that are blocked due to I/O requests, allowing efficient handling and scheduling of I/O operations.</li></ul><h3 id="bdbc95f8-5afe-4e41-871d-705476564df5" class=""><strong>5. Suspended Queue:</strong></h3><ul id="1090e08c-c595-4d99-a663-9362e6bbc187" class="bulleted-list"><li style="list-style-type:disc"><strong>Description:</strong> Includes processes that are in a <strong>Suspended</strong> state, either <strong>Ready Suspended</strong> (swapped out but ready to execute) or <strong>Blocked Suspended</strong> (waiting for an event and swapped out).</li></ul><ul id="83aca2a7-d3ac-4f22-a065-e5b35e186a3f" class="bulleted-list"><li style="list-style-type:disc"><strong>Purpose:</strong> Keeps track of processes that have been moved out of main memory to secondary storage, awaiting reactivation.</li></ul></details></li></ul><ul id="58c70f7a-3f43-4668-8817-9131c7ebed17" class="toggle"><li><details open=""><summary>Mostly used queues in the process life cycle</summary><h3 id="9dadf3c0-7520-4cca-99e0-f7de391d2aa0" class="">1. Job queue</h3><ul id="afc1de60-471e-4ce3-af32-78fd6c3b4f04" class="bulleted-list"><li style="list-style-type:disc">Processes in new state</li></ul><ul id="3ff7e178-58c4-4dcf-8fb4-7c099333732f" class="bulleted-list"><li style="list-style-type:disc">Present in secondary memory</li></ul><ul id="e97bca7e-ff38-4efb-b5f3-eab323eeb1bb" class="bulleted-list"><li style="list-style-type:disc">Job Scheduler → Long term scheduler(LTS) picks process from the pool and loads them into the memory for execution</li></ul><h3 id="d6ac68ac-c2cd-41e6-96fb-85f849b8069f" class="">2. Ready queue</h3><ul id="39fe60b1-251a-4ca4-9a2a-6ad2e4bf2c9a" class="bulleted-list"><li style="list-style-type:disc">Processes in ready state</li></ul><ul id="3a139752-9824-414d-a00c-4e1a7fbb3996" class="bulleted-list"><li style="list-style-type:disc">Present in main memory</li></ul><ul id="61b2a351-85c2-4589-bc82-195c04834ebc" class="bulleted-list"><li style="list-style-type:disc">CPU scheduler → Short Term Scheduler(STS) picks process from the ready queue and dispatch into the cpu</li></ul><h3 id="da07e95c-3cc8-45e1-9158-ac607dcbd7bb" class="">3. Waiting queue</h3><ul id="4e46bad6-6ea6-41a0-a85c-1762cdda03f9" class="bulleted-list"><li style="list-style-type:disc">Processes in wait state</li></ul></details></li></ul><ul id="681206bb-60de-4435-b101-40ab364f4748" class="toggle"><li><details open=""><summary>Dispatcher</summary><p id="556fb1fd-9958-4078-8641-b032d3295232" class="">The <strong>dispatcher</strong> is a component of the operating system responsible for managing process scheduling and context switching. </p><ul id="00e5751a-e086-4f7d-b727-46d8eb44bb29" class="bulleted-list"><li style="list-style-type:disc"><strong>Context Switching:</strong> The dispatcher saves the state of the currently running process and loads the state of the next process to be executed. This involves saving and restoring the process&#x27;s CPU registers, program counter, and other critical information.</li></ul><ul id="99ea3b3b-c024-4aba-a9dc-5839f6e09f1a" class="bulleted-list"><li style="list-style-type:disc"><strong>Process Switching:</strong> It handles the transition between processes by performing context switches, allowing multiple processes to share the CPU effectively.</li></ul><ul id="49bcf1c8-572c-422a-847a-4056ffeb70ab" class="bulleted-list"><li style="list-style-type:disc"><strong>Execution Control:</strong> The dispatcher <strong>transfers control from the operating system to the selected process</strong>, starting or resuming its execution.</li></ul><ul id="ae9af71b-8592-4fe1-9693-43f052332483" class="bulleted-list"><li style="list-style-type:disc"><strong>Efficiency:</strong> It ensures that the CPU is allocated to processes according to the scheduling algorithm, such as round-robin, priority scheduling, or others.</li></ul><h3 id="da7074f3-333f-459e-9697-35d431d9a3ba" class=""></h3></details></li></ul><hr id="04c2b068-e2a6-4660-a651-85e4ee5382b4"/><h3 id="01359847-8d11-4668-9b88-1b5cc3e8b349" class="">Process Schedulers</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="ffe08fc2-e48e-4508-b41d-3c3892e2e489"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="f7622d24-d137-4b25-88e8-b171cea4e892" class="">The <strong>Long-Term Scheduler</strong> (or <strong>Job Scheduler</strong>) is responsible for determining and managing the degree of multiprogramming in an operating system</p></div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="434ba5d7-5741-4b7c-8903-db9258c967dc"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="415e3ff4-d570-4ace-8c1e-605c02088f22" class="">Kernel perform the context switching and all other low level stuff<br/>User space does not perform these<br/></p></div></figure><ul id="9c4ffe3d-1d2f-43d9-9632-763ce59d0520" class="toggle"><li><details open=""><summary>Long Term Scheduler and Short Term Scheduler</summary><h3 id="87d2e3b4-6ccb-4e19-abf9-9b84dbd335d8" class="">1. <strong>Long-Term Scheduling</strong></h3><ul id="4cd5c6b5-ed81-42d0-abdd-ab8affe35269" class="bulleted-list"><li style="list-style-type:disc"><strong>Purpose</strong>: Long-term scheduling, also known as <strong>job scheduling</strong>, is responsible for controlling the admission of processes into the system. It determines which processes should be brought into the ready queue, from where they will eventually be dispatched for execution.</li></ul><ul id="330317bf-6e75-48a5-97d3-25b991a52cac" class="bulleted-list"><li style="list-style-type:disc"><strong>Functionality</strong>:<ul id="afc2b41d-e37f-46a7-bdd6-39fa80836973" class="bulleted-list"><li style="list-style-type:circle"><strong>Job Admission</strong>: The long-term scheduler decides how many and which processes should be allowed to enter the system&#x27;s ready queue, ensuring that the system doesn’t get overwhelmed.</li></ul><ul id="8d243bff-3094-4394-ab6e-059e3ffcc839" class="bulleted-list"><li style="list-style-type:circle"><strong>Process Mix Control</strong>: It controls the degree of multiprogramming, balancing the mix of I/O-bound and CPU-bound processes to optimize resource utilization.</li></ul><ul id="7af58167-5271-4bbd-98c8-d3d9731ad504" class="bulleted-list"><li style="list-style-type:circle"><strong>Frequency</strong>: Long-term scheduling is less frequent compared to short-term scheduling, as it only happens when a new process is created or when the system needs to admit more jobs into the ready queue.</li></ul><ul id="2db63cd2-2116-4124-8496-add640e1115d" class="bulleted-list"><li style="list-style-type:circle"><strong>Secondary Storage as a Holding Area</strong>: When a process is created, it is typically stored in secondary storage (like a hard drive or SSD) before it is admitted into the main memory (RAM). Secondary storage is larger but slower than primary memory, and it holds processes that are waiting to be executed.</li></ul></li></ul><ul id="64e4fbc1-a4b8-467d-90cb-0f6a750c3003" class="bulleted-list"><li style="list-style-type:disc"><strong>Example</strong>: In a batch processing system, the long-term scheduler might decide when to admit a batch job into the ready queue.</li></ul><h3 id="0db565e2-6998-4581-a795-0453ec1a3ef2" class="">2. <strong>Short-Term Scheduling</strong></h3><ul id="d2fb969e-cea1-43f4-aa79-8a7d47709b6e" class="bulleted-list"><li style="list-style-type:disc"><strong>Purpose</strong>: Short-term scheduling, also known as <strong>CPU scheduling</strong>, is responsible for determining which of the ready processes in the queue should be executed by the CPU next.</li></ul><ul id="77c316df-b56b-4d24-a54e-c0aba132b352" class="bulleted-list"><li style="list-style-type:disc"><strong>Functionality</strong>:<ul id="fa8d6bc4-6586-46eb-a4a7-924c976482d4" class="bulleted-list"><li style="list-style-type:circle"><strong>Process Selection</strong>: The short-term scheduler selects from among the processes that are ready to execute and allocates the CPU to one of them.</li></ul><ul id="0d1da5cd-6491-4b62-8a83-ed1142d48467" class="bulleted-list"><li style="list-style-type:circle"><strong>Response Time Optimization</strong>: It aims to optimize the system&#x27;s performance by reducing the response time and increasing throughput.</li></ul><ul id="3f07d042-4f0f-4c8f-be08-3925986799b5" class="bulleted-list"><li style="list-style-type:circle"><strong>Preemptive and Non-preemptive</strong>: Short-term scheduling can be preemptive (where a process can be interrupted) or non-preemptive (where a process runs to completion once started).</li></ul><ul id="cd13f8d0-31df-4c5b-bed2-8fa4c8b7b774" class="bulleted-list"><li style="list-style-type:circle"><strong>Frequency</strong>: Short-term scheduling occurs much more frequently since it happens every time the CPU becomes idle or a process needs to be rescheduled.</li></ul><ul id="4b5aaa0b-e585-4cb0-8d47-5588ceff79d5" class="bulleted-list"><li style="list-style-type:circle"><strong>Processes in Main Memory</strong>: The Short-Term Scheduler (STS) is responsible for deciding which of the processes that are already loaded into main memory should be given access to the CPU next. Since the CPU can only execute instructions from processes that are in main memory, STS works directly with processes that reside in RAM.</li></ul><ul id="b27a354d-cf3c-41f5-a256-f8dd6490f329" class="bulleted-list"><li style="list-style-type:circle"><strong>Ready Queue</strong>: The STS selects processes from the ready queue, which is a list of all processes that are in main memory and are ready to execute.</li></ul></li></ul><ul id="7b12a32a-6508-4d10-8ef8-302272d67e34" class="bulleted-list"><li style="list-style-type:disc"><strong>Example</strong>: In a time-sharing system, the short-term scheduler allocates a fixed time slice to each process and switches between them to ensure all processes get CPU time.</li></ul><p id="a1a75b99-2f61-4e57-8b9b-657efb0fe606" class="">
</p></details></li></ul><ul id="53adaea4-ec30-4072-a0d7-b6339de4c30c" class="toggle"><li><details open=""><summary>Journey of a program from secondary storage to running state process</summary><figure id="f2adeab4-dd43-4cbe-b151-a1f02dcbb87e" class="image"><a href="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/image%204.png"><img style="width:680px" src="Operating%20System(OS)%20fa94b13a71c3456fb1212a62e7b61d1b/image%204.png"/></a></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="4b379e8a-a798-4e1a-8e04-7058c32a43e5"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="04c3df56-6c72-4ce5-a144-9adc16c74e63" class="">Secondary storage → Job queue → Ready queue → Running</p></div></figure><h3 id="f2a17543-02b6-4577-ba45-26eeeeea6cfd" class="">1. <strong>From Secondary Storage to Job Queue</strong></h3><ul id="23c627fb-933f-494e-b546-67c9e06a976a" class="bulleted-list"><li style="list-style-type:disc"><strong>Role</strong>: <strong>Job Scheduler (Long-Term Scheduler)</strong><ul id="333de892-bfc5-4817-a6c5-78cb63469dd0" class="bulleted-list"><li style="list-style-type:circle"><strong>Function</strong>: The Job Scheduler (or Long-Term Scheduler) manages the job queue, which contains processes that are waiting in secondary storage to be loaded into main memory. When a new process is created or an existing process is ready to be admitted into the system, the Job Scheduler decides which processes should be moved from secondary storage into the job queue. This queue helps manage the degree of multiprogramming by controlling the number of processes waiting to be loaded into main memory.</li></ul></li></ul><h3 id="85e1a5bc-e005-41fe-9ef5-3c2317765fdc" class="">2. <strong>From Job Queue to Ready Queue</strong></h3><ul id="2b7763f0-fc94-4d0e-9e61-244ec27bd777" class="bulleted-list"><li style="list-style-type:disc"><strong>Role</strong>: <strong>Job Scheduler (Long-Term Scheduler)</strong><ul id="5889efa5-df39-41ba-bdaa-06561caf6476" class="bulleted-list"><li style="list-style-type:circle"><strong>Function</strong>: The Job Scheduler (or Long-Term Scheduler) periodically examines the job queue and selects processes to be moved from secondary storage into the ready queue (main memory). This decision is based on system load, resource availability, and scheduling policies. The selected processes are loaded into main memory, where they are then placed into the ready queue, where they await CPU allocation.</li></ul></li></ul><h3 id="06e2fe21-3089-4fe9-89db-e910015d4caf" class="">3. <strong>From Ready Queue to Running</strong></h3><ul id="e6c671c4-c4ce-4233-ad23-7a82c4e70f37" class="bulleted-list"><li style="list-style-type:disc"><strong>Role</strong>: <strong>Short-Term Scheduler (CPU Scheduler)</strong><ul id="d7dd5634-bfc4-472d-9edf-6ab25f754d9a" class="bulleted-list"><li style="list-style-type:circle"><strong>Function</strong>: The Short-Term Scheduler (or CPU Scheduler) manages the ready queue, which contains processes that are in main memory and ready to execute. The Short-Term Scheduler selects which process from the ready queue should be allocated CPU time next, based on the scheduling algorithm used (such as Round Robin, Priority Scheduling, etc.). The chosen process is then moved from the ready queue to the running state, where it executes on the CPU.</li></ul></li></ul></details></li></ul><ul id="ed15b1bc-dc08-4192-a3ba-eb54349e94ae" class="toggle"><li><details open=""><summary>Why LTS determines the degree of multiprogramming and why not STS?</summary><p id="01dada2b-1655-43fe-9814-4748409a605e" class="">Basically LTS brings processes into the memory</p><ol type="1" id="0e915cd2-6ed3-49cb-8ea3-1f55b434329d" class="numbered-list" start="1"><li><strong>Degree of Multiprogramming</strong>:<ul id="f3e31a48-8b57-49e9-af54-609020c13329" class="bulleted-list"><li style="list-style-type:disc"><strong>Definition</strong>: The degree of multiprogramming refers to the number of processes that are kept in main memory simultaneously. It affects how many processes are available for execution by the CPU at any given time.</li></ul><ul id="2c902a85-8079-4497-935f-6e54b4d041d6" class="bulleted-list"><li style="list-style-type:disc"><strong>Function</strong>: The Long-Term Scheduler controls the degree of multiprogramming by deciding which processes from secondary storage (disk) should be loaded into main memory. It ensures that the system maintains an optimal number of processes in memory to maximize CPU utilization while avoiding overloading the system.</li></ul></li></ol><ol type="1" id="459fa9a9-afc8-4b1d-8b66-f5e093a7de3d" class="numbered-list" start="2"><li><strong>Job Queue Management</strong>:<ul id="4e226388-68e9-452c-9595-566c7b25cba6" class="bulleted-list"><li style="list-style-type:disc"><strong>Process Admission</strong>: The Long-Term Scheduler manages the job queue, which contains processes waiting in secondary storage to be loaded into main memory. By selecting processes to be moved from this queue to the ready queue (main memory), the Long-Term Scheduler directly influences the degree of multiprogramming.</li></ul></li></ol><ol type="1" id="baebf49c-79c2-45ee-9c2e-7683d1f9011f" class="numbered-list" start="3"><li><strong>System Load Control</strong>:<ul id="f8cf8a3d-86c5-4cf2-b03d-999076493fee" class="bulleted-list"><li style="list-style-type:disc"><strong>Balancing</strong>: By controlling how many processes are loaded into memory, the Long-Term Scheduler helps balance the system’s load. It makes decisions based on factors such as system performance, memory availability, and current workload.</li></ul></li></ol><h3 id="eb8153c9-496c-4c05-bc88-8fb0e88fbe47" class="">Responsibility of STS</h3><p id="944d4343-85fa-44fd-8527-713e90d1d876" class="">The Short-Term Scheduler (or CPU Scheduler) deals with processes that are already in main memory and manages CPU allocation. It does not directly control the degree of multiprogramming but relies on the Long-Term Scheduler’s decisions regarding which processes are in memory.</p></details></li></ul><ul id="81c1fa21-dbf3-4ba9-8b78-acee1f528838" class="toggle"><li><details open=""><summary>Swapping and swap space → LTS,requirements,space</summary><h3 id="7ca811d4-59fe-4386-acf9-1c8beae1c66f" class="">Swapping</h3><p id="087ab032-caac-4ebd-8456-6b3bf66c0014" class="">Memory is limited. Due to continuos working of LTS, processes are loaded into <a href="http://memory.So">memory</a>. So it may happen that some process are using huge memory while some are not getting any memory.</p><p id="265aa6e8-02b5-4bbe-8943-0150d47132bf" class="">Swapping is the process of moving processes or parts of processes between main memory (RAM) and secondary storage (disk). This allows the operating system to free up memory by temporarily moving less critical processes to disk and later bringing them back into RAM when needed.</p><ul id="32e123fe-6852-4a04-b8ea-80457cb5213c" class="bulleted-list"><li style="list-style-type:disc"><strong>Swapping In</strong>: The process of moving a process from secondary storage (disk) into main memory (RAM). This is done when a process needs to be executed or when memory is available.</li></ul><ul id="4685d75f-5f1e-4cab-a63e-fff2be1b8b52" class="bulleted-list"><li style="list-style-type:disc"><strong>Swapping Out</strong>: The process of moving a process from main memory (RAM) to secondary storage (disk). This is done to free up memory for other processes or to manage memory more efficiently.</li></ul><h3 id="6666653b-695d-4d81-a9a0-5345ca3202c1" class="">Why we need swapping?</h3><ul id="5c9873a9-2c08-4863-b18a-841f41140fbc" class="bulleted-list"><li style="list-style-type:disc"><strong>Memory Management</strong>: Swapping helps manage the limited amount of RAM by freeing up space for processes that need immediate execution. It allows the system to handle more processes than would fit into RAM alone.</li></ul><ul id="23f33738-f840-434d-a11d-4a98560cf878" class="bulleted-list"><li style="list-style-type:disc"><strong>System Performance</strong>: By swapping less critical processes out of RAM, the operating system ensures that more important processes can be loaded into memory and executed, thus improving overall system performance and responsiveness.</li></ul><ul id="8589ec48-14cd-4ed7-bcc4-410cdcf020c1" class="bulleted-list"><li style="list-style-type:disc"><strong>Flexibility</strong>: It provides flexibility in handling varying workloads and memory demands, ensuring that the system can adapt to changes in process activity and resource requirements.</li></ul><h3 id="430ecf39-8a3e-48a9-9e18-d4dabd08e1ce" class="">How LTS leads to situation we came to the requirement of swapping?</h3><ul id="9efc4ca3-bd50-4149-b4d3-e5c0a5b2188e" class="bulleted-list"><li style="list-style-type:disc"><strong>Managing Process Admission</strong>: The Long-Term Scheduler (LTS) decides which processes should be admitted into the system from secondary storage and loaded into RAM. It influences the degree of multiprogramming by controlling the number of processes in main memory.</li></ul><ul id="9747869f-b380-4755-a020-1fb4efb16f8b" class="bulleted-list"><li style="list-style-type:disc"><strong>Triggering Swapping</strong>: As the LTS manages the admission of processes into memory, it can lead to situations where memory becomes full or overloaded. In such cases, swapping becomes necessary to manage memory effectively. The LTS’s decisions can indirectly create the need for swapping by increasing the number of processes competing for limited memory resources.</li></ul><ul id="81e2d9c0-e158-4e47-beb4-2818ce603bed" class="bulleted-list"><li style="list-style-type:disc"><strong>Balancing System Load</strong>: By adjusting the degree of multiprogramming, the LTS helps balance system load and prevent memory exhaustion. When memory is full, the Medium-Term Scheduler may be invoked to handle swapping, ensuring that processes can still be managed and executed efficiently.</li></ul><h3 id="59a77f18-ec2b-49fa-b9e0-22973194d329" class="">Swapping Space</h3><p id="cb18b940-a954-4458-863f-b120e99ab698" class="">Swapping space refers to the area of secondary storage allocated for the purpose of swapping processes in and out of main memory. It is typically a dedicated partition or file on a disk.</p><ul id="3c8ca317-0d92-4822-99a2-330d2dd7c321" class="bulleted-list"><li style="list-style-type:disc"><strong>Purpose</strong>: Swapping space acts as a temporary holding area for processes that are not currently in use. It ensures that there is enough room to manage the processes in the system efficiently.</li></ul><ul id="7e7e2c85-63b0-436f-b398-7820990ddc7e" class="bulleted-list"><li style="list-style-type:disc"><strong>Characteristics</strong>: Swapping space is designed to be large enough to accommodate multiple processes and their data, and it must be fast enough to minimize the impact on system performance.</li></ul><h3 id="57467a49-749e-4841-91fc-098c7f043555" class="">Why secondary storage is used</h3><ul id="c28dff41-ea34-44c1-9c52-ccc1e255549b" class="bulleted-list"><li style="list-style-type:disc"><strong>Capacity</strong>: Secondary storage has a much larger capacity compared to main memory. It can store a vast amount of data and programs that are not immediately needed but must be preserved.</li></ul><ul id="b4dc759a-2b03-499f-a0e6-c164571e7445" class="bulleted-list"><li style="list-style-type:disc"><strong>Cost</strong>: Secondary storage is less expensive per unit of storage compared to RAM. This makes it a cost-effective solution for managing large volumes of data.</li></ul></details></li></ul><ul id="fa97eb49-28a6-48bd-8a58-ac0a9dacdf0e" class="toggle"><li><details open=""><summary>Medium term scheduler(MTS)</summary><p id="6f40b693-ee56-4184-8a9c-54e004920583" class="">MTS is responsible for swapping</p><p id="7a21e7c1-e3c2-406e-8245-9ca547f42f64" class="">The <strong>Medium-Term Scheduler</strong> (or <strong>Medium-Term Scheduler</strong>) is a component of the operating system responsible for managing processes in a way that fits between the functions of the Long-Term Scheduler and the Short-Term Scheduler. Here’s an overview of its role and functions:</p><h3 id="c71aa8e8-e70a-4564-a538-81411737d373" class=""><strong>Role of the Medium-Term Scheduler</strong></h3><ol type="1" id="c72dad15-ca00-4133-99e3-80a34e9b37a4" class="numbered-list" start="1"><li><strong>Process Swapping</strong>:<ul id="002b5f47-c545-4657-91c7-c030be3ee972" class="bulleted-list"><li style="list-style-type:disc"><strong>Swapping In and Out</strong>: The Medium-Term Scheduler handles the swapping of processes between main memory (RAM) and secondary storage (disk). When the main memory becomes full or overloaded, the Medium-Term Scheduler may swap out some processes from RAM to disk (secondary storage) to free up space. Conversely, it may swap processes from the disk back into RAM when needed.</li></ul></li></ol><ol type="1" id="9132bcb1-6ce9-49dc-9173-53bdae9747a3" class="numbered-list" start="2"><li><strong>Context Switching</strong>:<ul id="c459c6b3-18d5-4f20-aba2-f76e4c2928d6" class="bulleted-list"><li style="list-style-type:disc"><strong>Managing Execution Contexts</strong>: It deals with processes that are in the “suspended” state, where they are not actively running or ready but can be brought back into main memory. This is often done to manage system load and ensure that the CPU has access to processes that are most likely to be immediately executable.</li></ul></li></ol><ol type="1" id="953b5087-ce41-4b37-a910-df6db93dd5f9" class="numbered-list" start="3"><li><strong>Memory Management</strong>:<ul id="ab51b560-e2c0-45c5-86c4-3349b9ff2982" class="bulleted-list"><li style="list-style-type:disc"><strong>Balancing Memory Usage</strong>: The Medium-Term Scheduler helps in managing the system’s memory resources by ensuring that the most important or urgent processes are kept in main memory, while less critical processes are temporarily moved to secondary storage.</li></ul></li></ol><ol type="1" id="2e407cbc-88a1-47b4-97da-720451615dbd" class="numbered-list" start="4"><li><strong>Process Suspension</strong>:<ul id="183d8c9e-84ce-4ad1-9926-80b0dcaf3408" class="bulleted-list"><li style="list-style-type:disc"><strong>Temporary Suspension</strong>: It can suspend and resume processes as needed, based on their priority and the current system load. This helps in optimizing system performance and ensuring that the CPU is efficiently utilized.</li></ul></li></ol><h3 id="66906dda-ea04-45ee-a378-5a84aff18f7a" class=""><strong>Interaction with Other Schedulers</strong></h3><ul id="23ab3afa-298b-4fe6-9e24-9483c82d81d4" class="bulleted-list"><li style="list-style-type:disc"><strong>Long-Term Scheduler</strong>: The Long-Term Scheduler moves processes from secondary storage to the ready queue. The Medium-Term Scheduler, on the other hand, manages processes already in main memory, handling their suspension and resumption.</li></ul><ul id="3f8c7ba8-2134-4e9a-be3c-c6a60a0fb4c0" class="bulleted-list"><li style="list-style-type:disc"><strong>Short-Term Scheduler</strong>: The Short-Term Scheduler deals with processes in the ready queue and manages which of them gets CPU time next. The Medium-Term Scheduler ensures that processes in main memory are appropriately managed to support the Short-Term Scheduler’s operations.</li></ul></details></li></ul><ul id="85a9a3e3-d854-4ecb-af09-f11a8ee82bb5" class="toggle"><li><details open=""><summary>Context switching vs Mode switching</summary><p id="227fb6c7-d85a-4d72-8eb5-71dc39e34567" class="">Context switching refers to the process of saving the current state of a running process or thread and loading the saved state of a different process or thread. This allows the CPU to switch between multiple processes or threads, giving the illusion of parallel execution on a single-core system. Key points about context switching:</p><ol type="1" id="79a98feb-c7de-4272-81be-6da53f880c64" class="numbered-list" start="1"><li>Occurs between processes or threads</li></ol><ol type="1" id="8219bc7c-9751-4db3-9c07-55cd2a993e6a" class="numbered-list" start="2"><li>Involves saving and restoring the entire execution context (registers, program counter, etc.)</li></ol><ol type="1" id="dc926b3f-c0a5-45cb-b907-7464ddf26bdb" class="numbered-list" start="3"><li>More time-consuming operation</li></ol><ol type="1" id="5c245a97-f56c-48b7-b4f6-2fc3aab11540" class="numbered-list" start="4"><li>Typically triggered by the scheduler or interrupts</li></ol><p id="58e755a0-8751-43e4-903a-f73edd436580" class="">Mode switching, on the other hand, refers to switching between different privilege levels within the same process, usually between user mode and kernel mode. Key points about mode switching:</p><ol type="1" id="4cef135a-3346-4d03-98b8-39d3a7489410" class="numbered-list" start="1"><li>Occurs within a single process</li></ol><ol type="1" id="bcb9c731-fe46-47ff-ab50-36b91f3cb791" class="numbered-list" start="2"><li>Switches between user mode (limited privileges) and kernel mode (full system access)</li></ol><ol type="1" id="5c995121-a3d4-4cbb-acdd-793ade2528b9" class="numbered-list" start="3"><li>Faster operation compared to context switching</li></ol><ol type="1" id="62d93787-83df-40ca-a7da-aead1cb762d7" class="numbered-list" start="4"><li>Typically triggered by system calls, exceptions, or interrupts</li></ol><p id="1571b038-f656-4955-91bc-b208c8df4d28" class="">The main differences are:</p><ul id="f677ead5-57f9-4401-b708-1865bd62b332" class="bulleted-list"><li style="list-style-type:disc">Scope: Context switching is between processes/threads, mode switching is within a process</li></ul><ul id="af980abe-9b1c-4b63-9db4-8268244c6be8" class="bulleted-list"><li style="list-style-type:disc">Purpose: Context switching allows multitasking, mode switching allows safe access to privileged operations</li></ul><ul id="aee944b6-ba8c-4bcf-8f5d-6f12d156e761" class="bulleted-list"><li style="list-style-type:disc">Overhead: Context switching has higher overhead due to saving/restoring more state</li></ul><p id="34e7d68b-e853-4272-b595-acb81f05b2b8" class="">
</p></details></li></ul><ul id="8025dd28-927c-4d01-a7c7-5d09065953b5" class="toggle"><li><details open=""><summary>how job queue ready queue and wait queue behave for context and mode switching</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="24b276c9-0b13-45b3-915f-c4ca93565ec6"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="464bda58-fe1b-4a0e-aa2e-46571d39fb70" class="">The Context switching mainly work with the processes in ready queue and waiting queue</p></div></figure><p id="fb8b0a39-ff7a-4b65-870d-9133c109bed6" class="">Context Switching:</p><ol type="1" id="cd8bdbe0-2a2e-4112-9f1f-783f68546432" class="numbered-list" start="1"><li>Job Queue:<ul id="46562d9f-3db2-4cb6-8585-7e7cd9283874" class="bulleted-list"><li style="list-style-type:disc">Holds all processes in the system</li></ul><ul id="abf3528d-9b23-4d4c-b261-69d157f484e8" class="bulleted-list"><li style="list-style-type:disc">Processes in this queue are waiting to be admitted into the ready queue</li></ul><ul id="ae870f25-95cd-4ed0-9133-dacd6afc35e7" class="bulleted-list"><li style="list-style-type:disc">Not directly affected by context switches, but influences which processes might be switched to</li></ul></li></ol><ol type="1" id="338c4494-7130-4572-8d77-13de8ef38bd6" class="numbered-list" start="2"><li>Ready Queue:<ul id="36459c69-9e72-4fcc-88c8-496efb6ed518" class="bulleted-list"><li style="list-style-type:disc">Contains processes ready to execute</li></ul><ul id="a851ea71-3f2a-4451-af0a-7f2fc325ab1f" class="bulleted-list"><li style="list-style-type:disc">When a context switch occurs, the current process is typically moved to the end of the ready queue (if it&#x27;s still runnable)</li></ul><ul id="b56bc987-c91b-4e41-a3d4-eb68f5d925fa" class="bulleted-list"><li style="list-style-type:disc">The next process is selected from the front of the ready queue to run</li></ul></li></ol><ol type="1" id="f2148652-b00e-4db4-a328-6dc304dd0eae" class="numbered-list" start="3"><li>Wait Queue:<ul id="e5b05f28-c3fa-441b-8997-4eb373a4580b" class="bulleted-list"><li style="list-style-type:disc">Holds processes waiting for a specific event (e.g., I/O completion, resource availability)</li></ul><ul id="81c9b26e-495e-4e9c-8bfb-b03a9a7a25b1" class="bulleted-list"><li style="list-style-type:disc">During a context switch, if the current process needs to wait for an event, it&#x27;s moved to the appropriate wait queue</li></ul><ul id="1096fdb5-5e9c-46ba-96dc-fe2e0ba58b83" class="bulleted-list"><li style="list-style-type:disc">When the event occurs, the process moves back to the ready queue</li></ul></li></ol><p id="57654908-c65c-4eb1-9923-57951738e8c2" class="">Mode Switching:</p><ol type="1" id="8ee4fcfb-96e7-4014-ba90-eb0599c4f72b" class="numbered-list" start="1"><li>Job Queue:<ul id="8aba4257-763f-4335-9495-11db7c47122b" class="bulleted-list"><li style="list-style-type:disc">Not directly affected by mode switches</li></ul><ul id="c0de3c3f-6c69-4fa6-a4ce-ba168a390925" class="bulleted-list"><li style="list-style-type:disc">Remains unchanged as mode switches occur within a single process</li></ul></li></ol><ol type="1" id="38d8aac1-0c4f-4268-92a1-fa55b1c58d34" class="numbered-list" start="2"><li>Ready Queue:<ul id="9f583abd-9680-4439-aef3-9b5b1575f685" class="bulleted-list"><li style="list-style-type:disc">Generally not affected by mode switches</li></ul><ul id="c6a44b79-1965-44ab-9750-f27e981aff0d" class="bulleted-list"><li style="list-style-type:disc">The process remains in the ready queue (or running state) during a mode switch</li></ul></li></ol><ol type="1" id="80488508-24b1-4fc7-86a2-73cbac1f1a09" class="numbered-list" start="3"><li>Wait Queue:<ul id="fe630501-11b1-41b2-a977-38bb4a89e723" class="bulleted-list"><li style="list-style-type:disc">Usually not directly affected by mode switches</li></ul><ul id="833b5590-52a8-424b-8847-ab765aeb9762" class="bulleted-list"><li style="list-style-type:disc">However, if a mode switch is triggered by a system call that requires waiting (e.g., I/O operation), the process might be moved to a wait queue after the mode switch</li></ul></li></ol><p id="01bbdff9-1c62-4b24-9d5f-94ee47f18153" class="">Key Differences:</p><ol type="1" id="a7693967-210c-4f93-b291-2071d83596c0" class="numbered-list" start="1"><li>Queue Manipulation:<ul id="3a8cb116-c291-495c-b9c0-141fad8ff71e" class="bulleted-list"><li style="list-style-type:disc">Context switching involves significant queue manipulation (moving processes between ready and wait queues)</li></ul><ul id="8eea65c1-02c7-4831-b1d1-8ec0191daebd" class="bulleted-list"><li style="list-style-type:disc">Mode switching typically doesn&#x27;t involve queue changes, as it occurs within a single process</li></ul></li></ol><ol type="1" id="5bf0c01b-af9f-428e-a17e-c4a984684880" class="numbered-list" start="2"><li>Scheduling Impact:<ul id="468f0417-382a-4fc0-9ede-d9bf8a62d503" class="bulleted-list"><li style="list-style-type:disc">Context switches often involve scheduler decisions, affecting queue order</li></ul><ul id="99ce8f17-751f-4cc9-9d5b-5137d9360365" class="bulleted-list"><li style="list-style-type:disc">Mode switches don&#x27;t usually impact scheduling or queue order</li></ul></li></ol><ol type="1" id="87374df1-8277-4185-85ef-7b54ca9c0e7b" class="numbered-list" start="3"><li>Duration in Queues:<ul id="63857e92-af12-418a-9864-88ec840a2763" class="bulleted-list"><li style="list-style-type:disc">Context switches can result in processes spending time in different queues</li></ul><ul id="4248d26b-2c5d-448a-acf6-29ea1c2c1e9d" class="bulleted-list"><li style="list-style-type:disc">Mode switches generally don&#x27;t change a process&#x27;s queue status</li></ul></li></ol><ol type="1" id="5e9764be-d6ce-4a08-b02d-2f9e5892cb6a" class="numbered-list" start="4"><li>System-wide vs. Process-specific:<ul id="ee60791f-97c4-4ec6-8c55-0e54f3ed58f3" class="bulleted-list"><li style="list-style-type:disc">Context switching queue operations affect the overall system state</li></ul><ul id="11b8c9cc-dc55-4e9d-8013-38fe8acf249b" class="bulleted-list"><li style="list-style-type:disc">Mode switching queue behavior (if any) is typically process-specific</li></ul></li></ol><p id="fd0dd722-a083-4cea-b934-72f32dfc81bb" class="">In summary, context switching heavily involves all three types of queues and significantly affects their states. Mode switching, being an intra-process operation, has minimal direct impact on these queues, although it can indirectly lead to queue changes if it results in operations that require waiting.</p></details></li></ul><ul id="2cd460f5-07b3-4cba-a1a4-011d54e865b5" class="toggle"><li><details open=""><summary>init process (traditionally with PID 1) and <span style="border-bottom:0.05em solid">its variant systemd</span></summary><p id="d4552103-c106-4396-982b-9ad8e3eb97eb" class="">The init process (traditionally with Process ID 1) is the first process started during the boot sequence of a Unix-like operating system. It runs until the system is shut down.</p><p id="9a8d1b4f-92f8-47a1-8449-ae965f106ac2" class="">The init process (traditionally with Process ID 1) is the first process started during the boot sequence of a Unix-like operating system. It runs until the system is shut down.</p><h3 id="d11823c3-0594-45e2-9376-e614059b357f" class="">Key Responsibilities:</h3><ul id="f764c105-be42-4a73-ae5b-a532e99e3ad0" class="bulleted-list"><li style="list-style-type:disc">Initializing the system</li></ul><ul id="e2f7dc4e-4263-4701-ac10-dc30dd1abf7b" class="bulleted-list"><li style="list-style-type:disc">Spawning other processes</li></ul><ul id="83eac8fc-26f8-442b-8053-c744e14c3a8a" class="bulleted-list"><li style="list-style-type:disc">Adopting orphaned processes</li></ul><ul id="71218f45-4dd4-46d6-ae65-75aa9b31a87e" class="bulleted-list"><li style="list-style-type:disc">Reaping zombie processes</li></ul><ul id="0cbbcc34-7091-4ba4-8842-509cba144b53" class="bulleted-list"><li style="list-style-type:disc">Managing system runlevels or targets (in traditional SysV init systems)</li></ul><h3 id="77df5a52-803a-41d4-bdbe-419e20e0c39c" class="">Variants</h3><ul id="9bbf4e60-7f4e-4af0-b9d7-d5dccadc2f42" class="bulleted-list"><li style="list-style-type:disc">Traditional SysV init</li></ul><ul id="363d5c2d-6cba-4461-94e3-8b7680d32c2c" class="bulleted-list"><li style="list-style-type:disc">Upstart (used in older Ubuntu versions)</li></ul><ul id="e2a6e26f-0158-45ab-acaa-a9fcaea48bb7" class="bulleted-list"><li style="list-style-type:disc">systemd (widely used in modern Linux distributions)</li></ul><ul id="995b84a5-9f58-4a68-9eb3-0ee02cf7463b" class="bulleted-list"><li style="list-style-type:disc">launchd (used in macOS)</li></ul><h3 id="df6b0ec3-8e13-45e1-a10c-258730d314f2" class="">system v init</h3><ul id="0ec2eeb3-1ed4-4c80-b9cb-20b4934ec7af" class="bulleted-list"><li style="list-style-type:disc">Uses runlevels to determine which services should be running</li></ul><ul id="2884d39e-4225-4a22-8b76-ffa79371fee2" class="bulleted-list"><li style="list-style-type:disc">Starts services sequentially, which can be slower on boot</li></ul><h3 id="40d5faa7-b9cb-4676-9ae1-0a41030619a9" class="">systemd</h3><ul id="ac2c436a-dc07-44ec-9d29-ddd95bcf36ab" class="bulleted-list"><li style="list-style-type:disc">Modern replacement for SysV init in many Linux distributions</li></ul><ul id="a8da0f14-6b05-4d19-9b18-dd91827b3c07" class="bulleted-list"><li style="list-style-type:disc">Allows parallel starting of services, potentially faster boot times</li></ul><ul id="0616d719-84ef-4a4b-a5b2-9086d9706731" class="bulleted-list"><li style="list-style-type:disc">Uses targets instead of runlevels</li></ul><ul id="acad64db-4f5d-40e2-84c9-2c40d80b6a62" class="bulleted-list"><li style="list-style-type:disc">Provides more advanced features like on-demand starting of services</li></ul></details></li></ul><ul id="c3b14e57-5b68-4470-a3f1-c3b7e070b55b" class="toggle"><li><details open=""><summary>when does a process pid is removed from the process table?</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="f756d220-e665-4084-8540-95488931652a"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="c66f42bd-3ba3-44d9-a6ca-70f7c30aea2c" class="">The child is removed from the process table only when the parent collected the exit status of the child. The child may be terminated but will remain zombie until the exit status is collected</p></div></figure><ul id="bd6f5a83-803a-4be8-b871-7bf22ecab879" class="bulleted-list"><li style="list-style-type:disc">Normal Process Termination:<ul id="b80a6104-40fc-453d-9b11-6f9afac21d2e" class="bulleted-list"><li style="list-style-type:circle">When a process terminates normally (e.g., by calling exit() or returning from main()).</li></ul><ul id="69b0b17f-cd30-4596-b248-181a681d231b" class="bulleted-list"><li style="list-style-type:circle">The process enters a &quot;terminated&quot; state but remains in the process table as a zombie.</li></ul></li></ul><ul id="46ebff72-86c7-4f91-88c7-74fb34b37e1d" class="bulleted-list"><li style="list-style-type:disc">After Parent Collects Exit Status:<ul id="f9b65e94-fdf8-4845-b3c1-0718ab7c2434" class="bulleted-list"><li style="list-style-type:circle">The PID is fully removed only after the parent process has collected the exit status.</li></ul><ul id="327da32d-9060-423e-8f07-a460d4519edf" class="bulleted-list"><li style="list-style-type:circle">This is typically done using the wait() or waitpid() system calls.</li></ul><ul id="0481c4c6-de6d-4be3-a76a-bd6803908993" class="bulleted-list"><li style="list-style-type:circle">Once collected, the zombie process is removed from the process table.</li></ul></li></ul><ul id="e314ae93-1f33-4b4e-b6cf-0a5340def0c2" class="bulleted-list"><li style="list-style-type:disc">Orphan Process Termination:<ul id="82b54d44-6702-455a-988d-0aecbb2a65ce" class="bulleted-list"><li style="list-style-type:circle">If a process becomes an orphan (parent terminates before it), init adopts it.</li></ul><ul id="c177893b-be71-4aed-8624-b666e06f32c2" class="bulleted-list"><li style="list-style-type:circle">When the orphan terminates, init automatically collects its exit status.</li></ul><ul id="5a3f5662-608b-4083-a491-5d3ff42518ae" class="bulleted-list"><li style="list-style-type:circle">The PID is then removed from the process table.</li></ul></li></ul><ul id="0b402bd7-1d04-4201-8636-ddd89f50342d" class="bulleted-list"><li style="list-style-type:disc">Forced Termination:<ul id="607ce138-d05a-4d7d-8034-421eb11caf86" class="bulleted-list"><li style="list-style-type:circle">When a process is terminated by a signal (e.g., SIGKILL).</li></ul><ul id="0227d491-54f9-4166-bb6c-52016e4e2ae0" class="bulleted-list"><li style="list-style-type:circle">The process still becomes a zombie until its exit status is collected.</li></ul></li></ul><ul id="8c37cf4b-ed62-4f6a-9d1e-ff21686b8b48" class="bulleted-list"><li style="list-style-type:disc">System Reboot:<ul id="f953024d-4e87-4a63-8c8c-947a0bac57a3" class="bulleted-list"><li style="list-style-type:circle">All PIDs are cleared from the process table when the system reboots.</li></ul></li></ul><ul id="a5bdeafd-8725-43a0-920d-649d169e27c7" class="bulleted-list"><li style="list-style-type:disc">PID Reuse:<ul id="bf9f3c1d-da66-405f-8fdc-c7f6936f2fae" class="bulleted-list"><li style="list-style-type:circle">After a PID is removed, it becomes available for reuse.</li></ul><ul id="3591c653-2b2f-457c-a2ca-326880fff2d9" class="bulleted-list"><li style="list-style-type:circle">Most systems wait for a period before reusing PIDs to prevent confusion.</li></ul></li></ul><ul id="7d4c2e4a-bff6-4a26-8855-58bde5f96320" class="bulleted-list"><li style="list-style-type:disc">Process Table Overflow Prevention:<ul id="1ffcd4d3-d139-4d9a-bb7e-be2363f60591" class="bulleted-list"><li style="list-style-type:circle">If the process table is near capacity, the system might more aggressively remove zombie processes.</li></ul></li></ul><p id="bb88856d-8e56-4047-a0e8-c295930e612b" class="">In the following code</p><ul id="9c4ffb86-7a52-44fb-8da0-0f96adc56fc8" class="bulleted-list"><li style="list-style-type:disc">A child process is created.</li></ul><ul id="083b91f0-c041-445a-b53d-13675ab9169a" class="bulleted-list"><li style="list-style-type:disc">The child runs for 2 seconds and exits.</li></ul><ul id="2c23a477-cffc-490b-9b2c-ed408f75c1ce" class="bulleted-list"><li style="list-style-type:disc">The parent waits for 5 seconds (during which the child becomes a zombie).</li></ul><ul id="6dbb792f-fd1e-4d1b-93e4-6cb191f9923e" class="bulleted-list"><li style="list-style-type:disc">The parent collects the child&#x27;s exit status using wait().</li></ul><ul id="c9263bfa-3db4-42cc-8ab0-5eba5f0e472e" class="bulleted-list"><li style="list-style-type:disc">After wait() returns, the child&#x27;s PID is removed from the process table.</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3e6d9f3f-87b8-4d1f-99af-34fd39eca789" class="code"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    pid_t pid = fork();

    if (pid &lt; 0) {
        perror(&quot;fork failed&quot;);
        exit(1);
    } else if (pid == 0) {
        // Child process
        printf(&quot;Child process (PID: %d) is running\n&quot;, getpid());
        sleep(2);
        printf(&quot;Child process (PID: %d) is exiting\n&quot;, getpid());
        exit(0);
    } else {
        // Parent process
        printf(&quot;Parent process (PID: %d) created child (PID: %d)\n&quot;, getpid(), pid);
        sleep(5);
        
        int status;
        pid_t child_pid = wait(&amp;status);
        
        if (child_pid &gt; 0) {
            printf(&quot;Parent collected exit status of child (PID: %d)\n&quot;, child_pid);
            printf(&quot;Child&#x27;s PID is now removed from the process table\n&quot;);
        }
    }

    return 0;
}</code></pre></details></li></ul><ul id="bae35f41-7ab2-466f-ac3c-3a9776ca3c08" class="toggle"><li><details open=""><summary>Orphan process</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="0eb9842f-48d4-4258-8bad-f3014a55f58a"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="9ada1586-1b90-4a3f-ae63-a82d1d3ecd4f" class="">We can see the parent of process using ppid</p></div></figure><p id="9c1720a6-a1b8-437b-b17c-f801230793fe" class="">A process whose parent process no more exists i.e. either finished or terminated without waiting for its child process to terminate is called an orphan process.<br/>In the following code, parent finishes execution and exits while the child process is still executing and is called an orphan process now.<br/></p><p id="bc406ee6-4e55-4a11-ab4d-67c6a4debed3" class="">However, the orphan process is soon adopted by init process, once its parent process dies.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ff3077aa-f0d0-4c4f-a09d-82179689c77e" class="code"><code class="language-C">#include&lt;stdio.h&gt; 
#include &lt;sys/types.h&gt; 
#include &lt;unistd.h&gt; 
  
int main() 
{ 
    // Create a child process       
    int pid = fork(); 
  
    if (pid &gt; 0) 
        printf(&quot;in parent process&quot;); 
  
    // Note that pid is 0 in child process 
    // and negative if fork() fails 
    else if (pid == 0) 
    { 
        sleep(30); 
        printf(&quot;in child process&quot;); 
    } 
  
    return 0; 
} </code></pre></details></li></ul><ul id="cb04d939-8eee-47a8-8c46-862fbbf7e293" class="toggle"><li><details open=""><summary>Zombie process</summary><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1c4e33ae-fc24-493d-b780-9c9ccbf7243c"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><p id="92cd5e3c-2972-4b47-b828-020128aad8c6" class=""> <strong>the child process has &quot;died&quot; but has not yet been &quot;removing&quot;</strong></p></div></figure><p id="869a6152-70de-4099-987f-f9e4b07ae906" class="">A process which has finished the execution but still has entry in the process table to report to its parent process is known as a zombie process. A child process always first becomes a zombie before being removed from the process table. The parent process reads the exit status of the child process which reaps off the child process entry from the process table.</p><p id="991f83b5-d425-46f3-86ab-9cb2f58cbe1a" class="">In the following code, the child finishes its execution using exit() system call while the parent sleeps for 50 seconds, hence doesn’t call <strong><a href="https://en.wikipedia.org/wiki/Wait_%28system_call%29">wait()</a></strong> and the child process’s entry still exists in the process table.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="df94ecae-b8bb-4ac9-8b24-53e6357e3d8c" class="code"><code class="language-C">#include &lt;stdlib.h&gt; 
#include &lt;sys/types.h&gt; 
#include &lt;unistd.h&gt; 
int main() 
{ 
    // Fork returns process id 
    // in parent process 
    pid_t child_pid = fork(); 
  
    // Parent process  
    if (child_pid &gt; 0) 
        sleep(50); 
  
    // Child process 
    else        
        exit(0); 
  
    return 0; 
} </code></pre></details></li></ul><ul id="b2316bbd-261e-42fc-9f0a-bca75d1e8a06" class="toggle"><li><details open=""><summary>how init/systemd stops orphaned processes from becoming zombies?</summary><ul id="9b3eeb1c-01ac-4801-b9b2-ad77853945b8" class="bulleted-list"><li style="list-style-type:disc">Process Adoption:<ul id="fae31518-97cb-4509-941d-6039872653ca" class="bulleted-list"><li style="list-style-type:circle">When a parent process terminates before its children, init adopts these orphaned processes</li></ul><ul id="63d57544-1ab6-4173-a5c9-b94d97323a5f" class="bulleted-list"><li style="list-style-type:circle">This prevents orphaned processes from becoming zombies</li></ul></li></ul><ul id="605816e7-e33c-451b-ab5d-7d540bf7e7ca" class="bulleted-list"><li style="list-style-type:disc">Zombie Process Handling:<ul id="04d6b706-e293-4904-9d01-21e9696d8a8e" class="bulleted-list"><li style="list-style-type:circle">Init periodically checks for and reaps/removes zombie processes</li></ul><ul id="d5c9d05c-1348-41ec-8d49-1ef67683d48e" class="bulleted-list"><li style="list-style-type:circle">This frees up process table entries and other resources</li></ul></li></ul></details></li></ul><ul id="5d7d7f89-0ea5-4e59-9cbf-5fa888012c0b" class="toggle"><li><details open=""><summary>CPU bound task vs IO bound task</summary><p id="a06bc411-4679-4971-b2d6-d2a59d03cd5d" class="">A CPU-bound process requires more CPU time or spends more time in the running state. An I/O-bound process requires more I/O time and less CPU time. An I/O-bound process spends more time in the waiting state. </p></details></li></ul><p id="199bfe53-e9b9-4e41-8faf-5cd9fa15e4a3" class="">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>